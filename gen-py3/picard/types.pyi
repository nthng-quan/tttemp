#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

import folly.iobuf as _fbthrift_iobuf
import thrift.py3.types
import thrift.py3.exceptions
from thrift.py3.types import __NotSet, NOTSET
import typing as _typing
from typing_extensions import Final

import sys
import itertools


__property__ = property


class ColumnType(thrift.py3.types.Enum):
    BOOLEAN: ColumnType = ...
    TEXT: ColumnType = ...
    NUMBER: ColumnType = ...
    TIME: ColumnType = ...
    OTHERS: ColumnType = ...


class Mode(thrift.py3.types.Enum):
    LEXING: Mode = ...
    PARSING_WITHOUT_GUARDS: Mode = ...
    PARSING_WITH_GUARDS: Mode = ...
    PARSING_WITH_GUARDS_AND_TYPE_CHECKING: Mode = ...


class SQLSchema(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    class __fbthrift_IsSet:
        columnNames: bool
        columnTypes: bool
        tableNames: bool
        columnToTable: bool
        tableToColumns: bool
        foreignKeys: bool
        primaryKeys: bool
        pass

    columnNames: Final[_typing.Mapping[str, str]] = ...

    columnTypes: Final[_typing.Mapping[str, ColumnType]] = ...

    tableNames: Final[_typing.Mapping[str, str]] = ...

    columnToTable: Final[_typing.Mapping[str, str]] = ...

    tableToColumns: Final[_typing.Mapping[str, _typing.Sequence[str]]] = ...

    foreignKeys: Final[_typing.Mapping[str, str]] = ...

    primaryKeys: Final[_typing.Sequence[str]] = ...

    def __init__(
        self, *,
        columnNames: _typing.Optional[_typing.Mapping[str, str]]=None,
        columnTypes: _typing.Optional[_typing.Mapping[str, ColumnType]]=None,
        tableNames: _typing.Optional[_typing.Mapping[str, str]]=None,
        columnToTable: _typing.Optional[_typing.Mapping[str, str]]=None,
        tableToColumns: _typing.Optional[_typing.Mapping[str, _typing.Sequence[str]]]=None,
        foreignKeys: _typing.Optional[_typing.Mapping[str, str]]=None,
        primaryKeys: _typing.Optional[_typing.Sequence[str]]=None
    ) -> None: ...

    def __call__(
        self, *,
        columnNames: _typing.Union[_typing.Mapping[str, str], __NotSet, None]=NOTSET,
        columnTypes: _typing.Union[_typing.Mapping[str, ColumnType], __NotSet, None]=NOTSET,
        tableNames: _typing.Union[_typing.Mapping[str, str], __NotSet, None]=NOTSET,
        columnToTable: _typing.Union[_typing.Mapping[str, str], __NotSet, None]=NOTSET,
        tableToColumns: _typing.Union[_typing.Mapping[str, _typing.Sequence[str]], __NotSet, None]=NOTSET,
        foreignKeys: _typing.Union[_typing.Mapping[str, str], __NotSet, None]=NOTSET,
        primaryKeys: _typing.Union[_typing.Sequence[str], __NotSet, None]=NOTSET
    ) -> SQLSchema: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['SQLSchema'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: 'SQLSchema') -> bool: ...
    def __gt__(self, other: 'SQLSchema') -> bool: ...
    def __le__(self, other: 'SQLSchema') -> bool: ...
    def __ge__(self, other: 'SQLSchema') -> bool: ...


class RegisterSQLSchemaException(thrift.py3.exceptions.GeneratedError, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    class __fbthrift_IsSet:
        dbId: bool
        message: bool
        pass

    dbId: Final[str] = ...

    message: Final[str] = ...

    def __init__(
        self, *,
        dbId: _typing.Optional[str]=None,
        message: _typing.Optional[str]=None
    ) -> None: ...

    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: 'RegisterSQLSchemaException') -> bool: ...
    def __gt__(self, other: 'RegisterSQLSchemaException') -> bool: ...
    def __le__(self, other: 'RegisterSQLSchemaException') -> bool: ...
    def __ge__(self, other: 'RegisterSQLSchemaException') -> bool: ...


class RegisterTokenizerException(thrift.py3.exceptions.GeneratedError, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    class __fbthrift_IsSet:
        message: bool
        pass

    message: Final[str] = ...

    def __init__(
        self, *,
        message: _typing.Optional[str]=None
    ) -> None: ...

    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: 'RegisterTokenizerException') -> bool: ...
    def __gt__(self, other: 'RegisterTokenizerException') -> bool: ...
    def __le__(self, other: 'RegisterTokenizerException') -> bool: ...
    def __ge__(self, other: 'RegisterTokenizerException') -> bool: ...


class TokenizerNotRegisteredException(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    class __fbthrift_IsSet:
        message: bool
        pass

    message: Final[str] = ...

    def __init__(
        self, *,
        message: _typing.Optional[str]=None
    ) -> None: ...

    def __call__(
        self, *,
        message: _typing.Union[str, __NotSet, None]=NOTSET
    ) -> TokenizerNotRegisteredException: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['TokenizerNotRegisteredException'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: 'TokenizerNotRegisteredException') -> bool: ...
    def __gt__(self, other: 'TokenizerNotRegisteredException') -> bool: ...
    def __le__(self, other: 'TokenizerNotRegisteredException') -> bool: ...
    def __ge__(self, other: 'TokenizerNotRegisteredException') -> bool: ...


class TokenizerPrefixException(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    class __fbthrift_IsSet:
        message: bool
        pass

    message: Final[str] = ...

    def __init__(
        self, *,
        message: _typing.Optional[str]=None
    ) -> None: ...

    def __call__(
        self, *,
        message: _typing.Union[str, __NotSet, None]=NOTSET
    ) -> TokenizerPrefixException: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['TokenizerPrefixException'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: 'TokenizerPrefixException') -> bool: ...
    def __gt__(self, other: 'TokenizerPrefixException') -> bool: ...
    def __le__(self, other: 'TokenizerPrefixException') -> bool: ...
    def __ge__(self, other: 'TokenizerPrefixException') -> bool: ...


class ModeException(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    class __fbthrift_IsSet:
        message: bool
        pass

    message: Final[str] = ...

    def __init__(
        self, *,
        message: _typing.Optional[str]=None
    ) -> None: ...

    def __call__(
        self, *,
        message: _typing.Union[str, __NotSet, None]=NOTSET
    ) -> ModeException: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['ModeException'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: 'ModeException') -> bool: ...
    def __gt__(self, other: 'ModeException') -> bool: ...
    def __le__(self, other: 'ModeException') -> bool: ...
    def __ge__(self, other: 'ModeException') -> bool: ...


class FeedFatalException(thrift.py3.types.Union, _typing.Hashable):
    class __fbthrift_IsSet:
        tokenizerNotRegisteredException: bool
        tokenizerPrefixException: bool
        modeException: bool
        pass

    tokenizerNotRegisteredException: Final['TokenizerNotRegisteredException'] = ...

    tokenizerPrefixException: Final['TokenizerPrefixException'] = ...

    modeException: Final['ModeException'] = ...

    def __init__(
        self, *,
        tokenizerNotRegisteredException: _typing.Optional['TokenizerNotRegisteredException']=None,
        tokenizerPrefixException: _typing.Optional['TokenizerPrefixException']=None,
        modeException: _typing.Optional['ModeException']=None
    ) -> None: ...

    def __hash__(self) -> int: ...
    def __lt__(self, other: 'FeedFatalException') -> bool: ...
    def __gt__(self, other: 'FeedFatalException') -> bool: ...
    def __le__(self, other: 'FeedFatalException') -> bool: ...
    def __ge__(self, other: 'FeedFatalException') -> bool: ...

    class Type(thrift.py3.types.Enum):
        EMPTY: FeedFatalException.Type = ...
        tokenizerNotRegisteredException: FeedFatalException.Type = ...
        tokenizerPrefixException: FeedFatalException.Type = ...
        modeException: FeedFatalException.Type = ...

    @staticmethod
    def fromValue(value: _typing.Union[None, 'TokenizerNotRegisteredException', 'TokenizerPrefixException', 'ModeException']) -> FeedFatalException: ...
    @__property__
    def value(self) -> _typing.Union[None, 'TokenizerNotRegisteredException', 'TokenizerPrefixException', 'ModeException']: ...
    @__property__
    def type(self) -> "FeedFatalException.Type": ...


class FeedException(thrift.py3.exceptions.GeneratedError, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    class __fbthrift_IsSet:
        feedFatalException: bool
        pass

    feedFatalException: Final['FeedFatalException'] = ...

    def __init__(
        self, *,
        feedFatalException: _typing.Optional['FeedFatalException']=None
    ) -> None: ...

    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: 'FeedException') -> bool: ...
    def __gt__(self, other: 'FeedException') -> bool: ...
    def __le__(self, other: 'FeedException') -> bool: ...
    def __ge__(self, other: 'FeedException') -> bool: ...


class FeedParseFailure(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    class __fbthrift_IsSet:
        input: bool
        contexts: bool
        description: bool
        pass

    input: Final[str] = ...

    contexts: Final[_typing.Sequence[str]] = ...

    description: Final[str] = ...

    def __init__(
        self, *,
        input: _typing.Optional[str]=None,
        contexts: _typing.Optional[_typing.Sequence[str]]=None,
        description: _typing.Optional[str]=None
    ) -> None: ...

    def __call__(
        self, *,
        input: _typing.Union[str, __NotSet, None]=NOTSET,
        contexts: _typing.Union[_typing.Sequence[str], __NotSet, None]=NOTSET,
        description: _typing.Union[str, __NotSet, None]=NOTSET
    ) -> FeedParseFailure: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['FeedParseFailure'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: 'FeedParseFailure') -> bool: ...
    def __gt__(self, other: 'FeedParseFailure') -> bool: ...
    def __le__(self, other: 'FeedParseFailure') -> bool: ...
    def __ge__(self, other: 'FeedParseFailure') -> bool: ...


class FeedTimeoutFailure(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    class __fbthrift_IsSet:
        message: bool
        pass

    message: Final[str] = ...

    def __init__(
        self, *,
        message: _typing.Optional[str]=None
    ) -> None: ...

    def __call__(
        self, *,
        message: _typing.Union[str, __NotSet, None]=NOTSET
    ) -> FeedTimeoutFailure: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['FeedTimeoutFailure'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: 'FeedTimeoutFailure') -> bool: ...
    def __gt__(self, other: 'FeedTimeoutFailure') -> bool: ...
    def __le__(self, other: 'FeedTimeoutFailure') -> bool: ...
    def __ge__(self, other: 'FeedTimeoutFailure') -> bool: ...


class FeedPartialSuccess(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    class __fbthrift_IsSet:
        pass

    def __init__(
        self, 
    ) -> None: ...

    def __call__(
        self, 
    ) -> FeedPartialSuccess: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['FeedPartialSuccess'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: 'FeedPartialSuccess') -> bool: ...
    def __gt__(self, other: 'FeedPartialSuccess') -> bool: ...
    def __le__(self, other: 'FeedPartialSuccess') -> bool: ...
    def __ge__(self, other: 'FeedPartialSuccess') -> bool: ...


class FeedCompleteSuccess(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    class __fbthrift_IsSet:
        leftover: bool
        pass

    leftover: Final[str] = ...

    def __init__(
        self, *,
        leftover: _typing.Optional[str]=None
    ) -> None: ...

    def __call__(
        self, *,
        leftover: _typing.Union[str, __NotSet, None]=NOTSET
    ) -> FeedCompleteSuccess: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['FeedCompleteSuccess'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: 'FeedCompleteSuccess') -> bool: ...
    def __gt__(self, other: 'FeedCompleteSuccess') -> bool: ...
    def __le__(self, other: 'FeedCompleteSuccess') -> bool: ...
    def __ge__(self, other: 'FeedCompleteSuccess') -> bool: ...


class FeedResult(thrift.py3.types.Union, _typing.Hashable):
    class __fbthrift_IsSet:
        feedParseFailure: bool
        feedTimeoutFailure: bool
        feedPartialSuccess: bool
        feedCompleteSuccess: bool
        pass

    feedParseFailure: Final['FeedParseFailure'] = ...

    feedTimeoutFailure: Final['FeedTimeoutFailure'] = ...

    feedPartialSuccess: Final['FeedPartialSuccess'] = ...

    feedCompleteSuccess: Final['FeedCompleteSuccess'] = ...

    def __init__(
        self, *,
        feedParseFailure: _typing.Optional['FeedParseFailure']=None,
        feedTimeoutFailure: _typing.Optional['FeedTimeoutFailure']=None,
        feedPartialSuccess: _typing.Optional['FeedPartialSuccess']=None,
        feedCompleteSuccess: _typing.Optional['FeedCompleteSuccess']=None
    ) -> None: ...

    def __hash__(self) -> int: ...
    def __lt__(self, other: 'FeedResult') -> bool: ...
    def __gt__(self, other: 'FeedResult') -> bool: ...
    def __le__(self, other: 'FeedResult') -> bool: ...
    def __ge__(self, other: 'FeedResult') -> bool: ...

    class Type(thrift.py3.types.Enum):
        EMPTY: FeedResult.Type = ...
        feedParseFailure: FeedResult.Type = ...
        feedTimeoutFailure: FeedResult.Type = ...
        feedPartialSuccess: FeedResult.Type = ...
        feedCompleteSuccess: FeedResult.Type = ...

    @staticmethod
    def fromValue(value: _typing.Union[None, 'FeedParseFailure', 'FeedTimeoutFailure', 'FeedPartialSuccess', 'FeedCompleteSuccess']) -> FeedResult: ...
    @__property__
    def value(self) -> _typing.Union[None, 'FeedParseFailure', 'FeedTimeoutFailure', 'FeedPartialSuccess', 'FeedCompleteSuccess']: ...
    @__property__
    def type(self) -> "FeedResult.Type": ...


class BatchFeedResult(thrift.py3.types.Struct, _typing.Hashable, _typing.Iterable[_typing.Tuple[str, _typing.Any]]):
    class __fbthrift_IsSet:
        batchId: bool
        topToken: bool
        feedResult: bool
        pass

    batchId: Final[int] = ...

    topToken: Final[int] = ...

    feedResult: Final['FeedResult'] = ...

    def __init__(
        self, *,
        batchId: _typing.Optional[int]=None,
        topToken: _typing.Optional[int]=None,
        feedResult: _typing.Optional['FeedResult']=None
    ) -> None: ...

    def __call__(
        self, *,
        batchId: _typing.Union[int, __NotSet, None]=NOTSET,
        topToken: _typing.Union[int, __NotSet, None]=NOTSET,
        feedResult: _typing.Union['FeedResult', __NotSet, None]=NOTSET
    ) -> BatchFeedResult: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['BatchFeedResult'], bytes]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Tuple[str, _typing.Any]]: ...
    def __hash__(self) -> int: ...
    def __lt__(self, other: 'BatchFeedResult') -> bool: ...
    def __gt__(self, other: 'BatchFeedResult') -> bool: ...
    def __le__(self, other: 'BatchFeedResult') -> bool: ...
    def __ge__(self, other: 'BatchFeedResult') -> bool: ...


_List__i64T = _typing.TypeVar('_List__i64T', bound=_typing.Sequence[int])


class List__i64(_typing.Sequence[int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> int: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[int]: ...
    def __add__(self, other: _typing.Sequence[int]) -> 'List__i64': ...
    def __radd__(self, other: _List__i64T) -> _List__i64T: ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_List__List__i64T = _typing.TypeVar('_List__List__i64T', bound=_typing.Sequence[_typing.Sequence[int]])


class List__List__i64(_typing.Sequence[_typing.Sequence[int]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[_typing.Sequence[int]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[_typing.Sequence[int]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Sequence[int]]: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[int]]) -> 'List__List__i64': ...
    def __radd__(self, other: _List__List__i64T) -> _List__List__i64T: ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[int]]: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[int]]: ...


_List__BatchFeedResultT = _typing.TypeVar('_List__BatchFeedResultT', bound=_typing.Sequence['BatchFeedResult'])


class List__BatchFeedResult(_typing.Sequence['BatchFeedResult'], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence['BatchFeedResult']]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence['BatchFeedResult']: ...
    @_typing.overload
    def __getitem__(self, i: int) -> 'BatchFeedResult': ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence['BatchFeedResult']: ...
    def __add__(self, other: _typing.Sequence['BatchFeedResult']) -> 'List__BatchFeedResult': ...
    def __radd__(self, other: _List__BatchFeedResultT) -> _List__BatchFeedResultT: ...
    def __reversed__(self) -> _typing.Iterator['BatchFeedResult']: ...
    def __iter__(self) -> _typing.Iterator['BatchFeedResult']: ...


class Map__string_string(_typing.Mapping[str, str], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[str, str]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[str, str]: ...
    def __getitem__(self, key: str) -> str: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Map__string_ColumnType(_typing.Mapping[str, ColumnType], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[str, ColumnType]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[str, ColumnType]: ...
    def __getitem__(self, key: str) -> ColumnType: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


_List__stringT = _typing.TypeVar('_List__stringT', bound=_typing.Sequence[str])


class List__string(_typing.Sequence[str], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[str]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[str]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> str: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[str]: ...
    def __add__(self, other: _typing.Sequence[str]) -> 'List__string': ...
    def __radd__(self, other: _List__stringT) -> _List__stringT: ...
    def __reversed__(self) -> _typing.Iterator[str]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Map__string_List__string(_typing.Mapping[str, _typing.Sequence[str]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[str, _typing.Sequence[str]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[str, _typing.Sequence[str]]: ...
    def __getitem__(self, key: str) -> _typing.Sequence[str]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


ColumnId = str
TableId = str
DBId = str
Token = int
InputIds = List__i64
BatchId = int
