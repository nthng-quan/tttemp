#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
cimport cython as __cython
from cpython.object cimport PyTypeObject, Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.std_libcpp cimport sv_to_str as __sv_to_str, string_view as __cstring_view
from thrift.py3.types cimport (
    cSetOp as __cSetOp,
    richcmp as __richcmp,
    set_op as __set_op,
    setcmp as __setcmp,
    list_index as __list_index,
    list_count as __list_count,
    list_slice as __list_slice,
    list_getitem as __list_getitem,
    set_iter as __set_iter,
    map_iter as __map_iter,
    map_contains as __map_contains,
    map_getitem as __map_getitem,
    reference_shared_ptr as __reference_shared_ptr,
    get_field_name_by_index as __get_field_name_by_index,
    reset_field as __reset_field,
    translate_cpp_enum_to_python,
    SetMetaClass as __SetMetaClass,
    const_pointer_cast,
    constant_shared_ptr,
    NOTSET as __NOTSET,
    EnumData as __EnumData,
    EnumFlagsData as __EnumFlagsData,
    UnionTypeEnumData as __UnionTypeEnumData,
    createEnumDataForUnionType as __createEnumDataForUnionType,
)
cimport thrift.py3.std_libcpp as std_libcpp
cimport thrift.py3.serializer as serializer
import folly.iobuf as _fbthrift_iobuf
from folly.optional cimport cOptional
from folly.memory cimport to_shared_ptr as __to_shared_ptr
from folly.range cimport Range as __cRange

import sys
from collections.abc import Sequence, Set, Mapping, Iterable
import weakref as __weakref
import builtins as _builtins

cimport picard.types_reflection as _types_reflection


cdef __EnumData __ColumnType_enum_data  = __EnumData.create(thrift.py3.types.createEnumData[cColumnType](), ColumnType)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __ColumnTypeMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __ColumnType_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __ColumnType_enum_data.get_all_names()

    def __len__(cls):
        return __ColumnType_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __ColumnType_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class ColumnType(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __ColumnType_enum_data.get_by_name(name)


    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        EnumMetadata[cColumnType].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.ColumnType"


__SetMetaClass(<PyTypeObject*> ColumnType, <PyTypeObject*> __ColumnTypeMeta)


cdef __EnumData __Mode_enum_data  = __EnumData.create(thrift.py3.types.createEnumData[cMode](), Mode)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __ModeMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __Mode_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __Mode_enum_data.get_all_names()

    def __len__(cls):
        return __Mode_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __Mode_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class Mode(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __Mode_enum_data.get_by_name(name)


    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        EnumMetadata[cMode].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.Mode"


__SetMetaClass(<PyTypeObject*> Mode, <PyTypeObject*> __ModeMeta)



cdef __UnionTypeEnumData __FeedFatalException_union_type_enum_data  = __UnionTypeEnumData.create(
    __createEnumDataForUnionType[cFeedFatalException](),
    __FeedFatalExceptionType,
)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __FeedFatalException_Union_TypeMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __FeedFatalException_union_type_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __FeedFatalException_union_type_enum_data.get_all_names()

    def __len__(cls):
        return __FeedFatalException_union_type_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __FeedFatalException_union_type_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class __FeedFatalExceptionType(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __FeedFatalException_union_type_enum_data.get_by_name(name)


__SetMetaClass(<PyTypeObject*> __FeedFatalExceptionType, <PyTypeObject*> __FeedFatalException_Union_TypeMeta)


cdef __UnionTypeEnumData __FeedResult_union_type_enum_data  = __UnionTypeEnumData.create(
    __createEnumDataForUnionType[cFeedResult](),
    __FeedResultType,
)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __FeedResult_Union_TypeMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __FeedResult_union_type_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __FeedResult_union_type_enum_data.get_all_names()

    def __len__(cls):
        return __FeedResult_union_type_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __FeedResult_union_type_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class __FeedResultType(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __FeedResult_union_type_enum_data.get_by_name(name)


__SetMetaClass(<PyTypeObject*> __FeedResultType, <PyTypeObject*> __FeedResult_Union_TypeMeta)


@__cython.auto_pickle(False)
cdef class SQLSchema(thrift.py3.types.Struct):
    def __init__(SQLSchema self, **kwargs):
        self._cpp_obj = make_shared[cSQLSchema]()
        self._fields_setter = _fbthrift_types_fields.__SQLSchema_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(SQLSchema self, **kwargs):
        if not kwargs:
            return self
        cdef SQLSchema __fbthrift_inst = SQLSchema.__new__(SQLSchema)
        __fbthrift_inst._cpp_obj = make_shared[cSQLSchema](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__SQLSchema_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("SQLSchema", {
          "columnNames": deref(self._cpp_obj).columnNames_ref().has_value(),
          "columnTypes": deref(self._cpp_obj).columnTypes_ref().has_value(),
          "tableNames": deref(self._cpp_obj).tableNames_ref().has_value(),
          "columnToTable": deref(self._cpp_obj).columnToTable_ref().has_value(),
          "tableToColumns": deref(self._cpp_obj).tableToColumns_ref().has_value(),
          "foreignKeys": deref(self._cpp_obj).foreignKeys_ref().has_value(),
          "primaryKeys": deref(self._cpp_obj).primaryKeys_ref().has_value(),
        })

    @staticmethod
    cdef create(shared_ptr[cSQLSchema] cpp_obj):
        __fbthrift_inst = <SQLSchema>SQLSchema.__new__(SQLSchema)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def columnNames(self):

        if self.__fbthrift_cached_columnNames is None:
            self.__fbthrift_cached_columnNames = Map__string_string.create(__reference_shared_ptr(deref(self._cpp_obj).columnNames_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_columnNames

    @property
    def columnTypes(self):

        if self.__fbthrift_cached_columnTypes is None:
            self.__fbthrift_cached_columnTypes = Map__string_ColumnType.create(__reference_shared_ptr(deref(self._cpp_obj).columnTypes_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_columnTypes

    @property
    def tableNames(self):

        if self.__fbthrift_cached_tableNames is None:
            self.__fbthrift_cached_tableNames = Map__string_string.create(__reference_shared_ptr(deref(self._cpp_obj).tableNames_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_tableNames

    @property
    def columnToTable(self):

        if self.__fbthrift_cached_columnToTable is None:
            self.__fbthrift_cached_columnToTable = Map__string_string.create(__reference_shared_ptr(deref(self._cpp_obj).columnToTable_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_columnToTable

    @property
    def tableToColumns(self):

        if self.__fbthrift_cached_tableToColumns is None:
            self.__fbthrift_cached_tableToColumns = Map__string_List__string.create(__reference_shared_ptr(deref(self._cpp_obj).tableToColumns_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_tableToColumns

    @property
    def foreignKeys(self):

        if self.__fbthrift_cached_foreignKeys is None:
            self.__fbthrift_cached_foreignKeys = Map__string_string.create(__reference_shared_ptr(deref(self._cpp_obj).foreignKeys_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_foreignKeys

    @property
    def primaryKeys(self):

        if self.__fbthrift_cached_primaryKeys is None:
            self.__fbthrift_cached_primaryKeys = List__string.create(__reference_shared_ptr(deref(self._cpp_obj).primaryKeys_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_primaryKeys


    def __hash__(SQLSchema self):
        return  super().__hash__()

    def __copy__(SQLSchema self):
        cdef shared_ptr[cSQLSchema] cpp_obj = make_shared[cSQLSchema](
            deref(self._cpp_obj)
        )
        return SQLSchema.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cSQLSchema](
            self._cpp_obj,
            (<SQLSchema>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__SQLSchema()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cSQLSchema].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.SQLSchema"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cSQLSchema](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 7

    cdef _fbthrift_iobuf.IOBuf _serialize(SQLSchema self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cSQLSchema](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(SQLSchema self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cSQLSchema]()
        with nogil:
            needed = serializer.cdeserialize[cSQLSchema](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class RegisterSQLSchemaException(thrift.py3.exceptions.GeneratedError):
    def __init__(RegisterSQLSchemaException self, *args, **kwargs):
        self._cpp_obj = make_shared[cRegisterSQLSchemaException]()
        self._fields_setter = _fbthrift_types_fields.__RegisterSQLSchemaException_FieldsSetter.create(self._cpp_obj.get())
        super().__init__( *args, **kwargs)

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("RegisterSQLSchemaException", {
          "dbId": deref(self._cpp_obj).dbId_ref().has_value(),
          "message": deref(self._cpp_obj).message_ref().has_value(),
        })

    @staticmethod
    cdef create(shared_ptr[cRegisterSQLSchemaException] cpp_obj):
        __fbthrift_inst = <RegisterSQLSchemaException>RegisterSQLSchemaException.__new__(RegisterSQLSchemaException, (<bytes>deref(cpp_obj).what()).decode('utf-8'))
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        _builtins.Exception.__init__(__fbthrift_inst, *(v for _, v in __fbthrift_inst))
        return __fbthrift_inst

    @property
    def dbId(self):

        return (<bytes>deref(self._cpp_obj).dbId_ref().value()).decode('UTF-8')

    @property
    def message(self):

        return (<bytes>deref(self._cpp_obj).message_ref().value()).decode('UTF-8')


    def __hash__(RegisterSQLSchemaException self):
        return  super().__hash__()

    def __copy__(RegisterSQLSchemaException self):
        cdef shared_ptr[cRegisterSQLSchemaException] cpp_obj = make_shared[cRegisterSQLSchemaException](
            deref(self._cpp_obj)
        )
        return RegisterSQLSchemaException.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cRegisterSQLSchemaException](
            self._cpp_obj,
            (<RegisterSQLSchemaException>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__RegisterSQLSchemaException()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        ExceptionMetadata[cRegisterSQLSchemaException].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.RegisterSQLSchemaException"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cRegisterSQLSchemaException](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 2



@__cython.auto_pickle(False)
cdef class RegisterTokenizerException(thrift.py3.exceptions.GeneratedError):
    def __init__(RegisterTokenizerException self, *args, **kwargs):
        self._cpp_obj = make_shared[cRegisterTokenizerException]()
        self._fields_setter = _fbthrift_types_fields.__RegisterTokenizerException_FieldsSetter.create(self._cpp_obj.get())
        super().__init__( *args, **kwargs)

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("RegisterTokenizerException", {
          "message": deref(self._cpp_obj).message_ref().has_value(),
        })

    @staticmethod
    cdef create(shared_ptr[cRegisterTokenizerException] cpp_obj):
        __fbthrift_inst = <RegisterTokenizerException>RegisterTokenizerException.__new__(RegisterTokenizerException, (<bytes>deref(cpp_obj).what()).decode('utf-8'))
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        _builtins.Exception.__init__(__fbthrift_inst, *(v for _, v in __fbthrift_inst))
        return __fbthrift_inst

    @property
    def message(self):

        return (<bytes>deref(self._cpp_obj).message_ref().value()).decode('UTF-8')


    def __hash__(RegisterTokenizerException self):
        return  super().__hash__()

    def __copy__(RegisterTokenizerException self):
        cdef shared_ptr[cRegisterTokenizerException] cpp_obj = make_shared[cRegisterTokenizerException](
            deref(self._cpp_obj)
        )
        return RegisterTokenizerException.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cRegisterTokenizerException](
            self._cpp_obj,
            (<RegisterTokenizerException>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__RegisterTokenizerException()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        ExceptionMetadata[cRegisterTokenizerException].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.RegisterTokenizerException"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cRegisterTokenizerException](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 1



@__cython.auto_pickle(False)
cdef class TokenizerNotRegisteredException(thrift.py3.types.Struct):
    def __init__(TokenizerNotRegisteredException self, **kwargs):
        self._cpp_obj = make_shared[cTokenizerNotRegisteredException]()
        self._fields_setter = _fbthrift_types_fields.__TokenizerNotRegisteredException_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(TokenizerNotRegisteredException self, **kwargs):
        if not kwargs:
            return self
        cdef TokenizerNotRegisteredException __fbthrift_inst = TokenizerNotRegisteredException.__new__(TokenizerNotRegisteredException)
        __fbthrift_inst._cpp_obj = make_shared[cTokenizerNotRegisteredException](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__TokenizerNotRegisteredException_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("TokenizerNotRegisteredException", {
          "message": deref(self._cpp_obj).message_ref().has_value(),
        })

    @staticmethod
    cdef create(shared_ptr[cTokenizerNotRegisteredException] cpp_obj):
        __fbthrift_inst = <TokenizerNotRegisteredException>TokenizerNotRegisteredException.__new__(TokenizerNotRegisteredException)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def message(self):

        return (<bytes>deref(self._cpp_obj).message_ref().value()).decode('UTF-8')


    def __hash__(TokenizerNotRegisteredException self):
        return  super().__hash__()

    def __copy__(TokenizerNotRegisteredException self):
        cdef shared_ptr[cTokenizerNotRegisteredException] cpp_obj = make_shared[cTokenizerNotRegisteredException](
            deref(self._cpp_obj)
        )
        return TokenizerNotRegisteredException.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cTokenizerNotRegisteredException](
            self._cpp_obj,
            (<TokenizerNotRegisteredException>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__TokenizerNotRegisteredException()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cTokenizerNotRegisteredException].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.TokenizerNotRegisteredException"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cTokenizerNotRegisteredException](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 1

    cdef _fbthrift_iobuf.IOBuf _serialize(TokenizerNotRegisteredException self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cTokenizerNotRegisteredException](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(TokenizerNotRegisteredException self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cTokenizerNotRegisteredException]()
        with nogil:
            needed = serializer.cdeserialize[cTokenizerNotRegisteredException](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class TokenizerPrefixException(thrift.py3.types.Struct):
    def __init__(TokenizerPrefixException self, **kwargs):
        self._cpp_obj = make_shared[cTokenizerPrefixException]()
        self._fields_setter = _fbthrift_types_fields.__TokenizerPrefixException_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(TokenizerPrefixException self, **kwargs):
        if not kwargs:
            return self
        cdef TokenizerPrefixException __fbthrift_inst = TokenizerPrefixException.__new__(TokenizerPrefixException)
        __fbthrift_inst._cpp_obj = make_shared[cTokenizerPrefixException](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__TokenizerPrefixException_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("TokenizerPrefixException", {
          "message": deref(self._cpp_obj).message_ref().has_value(),
        })

    @staticmethod
    cdef create(shared_ptr[cTokenizerPrefixException] cpp_obj):
        __fbthrift_inst = <TokenizerPrefixException>TokenizerPrefixException.__new__(TokenizerPrefixException)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def message(self):

        return (<bytes>deref(self._cpp_obj).message_ref().value()).decode('UTF-8')


    def __hash__(TokenizerPrefixException self):
        return  super().__hash__()

    def __copy__(TokenizerPrefixException self):
        cdef shared_ptr[cTokenizerPrefixException] cpp_obj = make_shared[cTokenizerPrefixException](
            deref(self._cpp_obj)
        )
        return TokenizerPrefixException.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cTokenizerPrefixException](
            self._cpp_obj,
            (<TokenizerPrefixException>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__TokenizerPrefixException()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cTokenizerPrefixException].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.TokenizerPrefixException"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cTokenizerPrefixException](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 1

    cdef _fbthrift_iobuf.IOBuf _serialize(TokenizerPrefixException self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cTokenizerPrefixException](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(TokenizerPrefixException self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cTokenizerPrefixException]()
        with nogil:
            needed = serializer.cdeserialize[cTokenizerPrefixException](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class ModeException(thrift.py3.types.Struct):
    def __init__(ModeException self, **kwargs):
        self._cpp_obj = make_shared[cModeException]()
        self._fields_setter = _fbthrift_types_fields.__ModeException_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(ModeException self, **kwargs):
        if not kwargs:
            return self
        cdef ModeException __fbthrift_inst = ModeException.__new__(ModeException)
        __fbthrift_inst._cpp_obj = make_shared[cModeException](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__ModeException_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("ModeException", {
          "message": deref(self._cpp_obj).message_ref().has_value(),
        })

    @staticmethod
    cdef create(shared_ptr[cModeException] cpp_obj):
        __fbthrift_inst = <ModeException>ModeException.__new__(ModeException)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def message(self):

        return (<bytes>deref(self._cpp_obj).message_ref().value()).decode('UTF-8')


    def __hash__(ModeException self):
        return  super().__hash__()

    def __copy__(ModeException self):
        cdef shared_ptr[cModeException] cpp_obj = make_shared[cModeException](
            deref(self._cpp_obj)
        )
        return ModeException.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cModeException](
            self._cpp_obj,
            (<ModeException>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__ModeException()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cModeException].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.ModeException"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cModeException](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 1

    cdef _fbthrift_iobuf.IOBuf _serialize(ModeException self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cModeException](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(ModeException self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cModeException]()
        with nogil:
            needed = serializer.cdeserialize[cModeException](buf, self._cpp_obj.get(), proto)
        return needed




@__cython.auto_pickle(False)
cdef class FeedFatalException(thrift.py3.types.Union):
    Type = __FeedFatalExceptionType

    def __init__(
        self, *,
        TokenizerNotRegisteredException tokenizerNotRegisteredException=None,
        TokenizerPrefixException tokenizerPrefixException=None,
        ModeException modeException=None
    ):
        self._cpp_obj = __to_shared_ptr(cmove(FeedFatalException._make_instance(
          NULL,
          tokenizerNotRegisteredException,
          tokenizerPrefixException,
          modeException,
        )))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return FeedFatalException()
        if isinstance(value, TokenizerNotRegisteredException):
            return FeedFatalException(tokenizerNotRegisteredException=value)
        if isinstance(value, TokenizerPrefixException):
            return FeedFatalException(tokenizerPrefixException=value)
        if isinstance(value, ModeException):
            return FeedFatalException(modeException=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cFeedFatalException] _make_instance(
        cFeedFatalException* base_instance,
        TokenizerNotRegisteredException tokenizerNotRegisteredException,
        TokenizerPrefixException tokenizerPrefixException,
        ModeException modeException
    ) except *:
        cdef unique_ptr[cFeedFatalException] c_inst = make_unique[cFeedFatalException]()
        cdef bint any_set = False
        if tokenizerNotRegisteredException is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_tokenizerNotRegisteredException(deref((<TokenizerNotRegisteredException?> tokenizerNotRegisteredException)._cpp_obj))
            any_set = True
        if tokenizerPrefixException is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_tokenizerPrefixException(deref((<TokenizerPrefixException?> tokenizerPrefixException)._cpp_obj))
            any_set = True
        if modeException is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_modeException(deref((<ModeException?> modeException)._cpp_obj))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return cmove(c_inst)

    @staticmethod
    cdef create(shared_ptr[cFeedFatalException] cpp_obj):
        __fbthrift_inst = <FeedFatalException>FeedFatalException.__new__(FeedFatalException)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        __fbthrift_inst._load_cache()
        return __fbthrift_inst

    @property
    def tokenizerNotRegisteredException(self):
        if self.type.value != 1:
            raise TypeError(f'Union contains a value of type {self.type.name}, not tokenizerNotRegisteredException')
        return self.value

    @property
    def tokenizerPrefixException(self):
        if self.type.value != 2:
            raise TypeError(f'Union contains a value of type {self.type.name}, not tokenizerPrefixException')
        return self.value

    @property
    def modeException(self):
        if self.type.value != 3:
            raise TypeError(f'Union contains a value of type {self.type.name}, not modeException')
        return self.value


    def __hash__(FeedFatalException self):
        return  super().__hash__()

    cdef _load_cache(FeedFatalException self):
        self.type = FeedFatalException.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            self.value = TokenizerNotRegisteredException.create(make_shared[cTokenizerNotRegisteredException](deref(self._cpp_obj).get_tokenizerNotRegisteredException()))
        elif type == 2:
            self.value = TokenizerPrefixException.create(make_shared[cTokenizerPrefixException](deref(self._cpp_obj).get_tokenizerPrefixException()))
        elif type == 3:
            self.value = ModeException.create(make_shared[cModeException](deref(self._cpp_obj).get_modeException()))

    def __copy__(FeedFatalException self):
        cdef shared_ptr[cFeedFatalException] cpp_obj = make_shared[cFeedFatalException](
            deref(self._cpp_obj)
        )
        return FeedFatalException.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cFeedFatalException](
            self._cpp_obj,
            (<FeedFatalException>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__FeedFatalException()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cFeedFatalException].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.FeedFatalException"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cFeedFatalException](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 3

    cdef _fbthrift_iobuf.IOBuf _serialize(FeedFatalException self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cFeedFatalException](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(FeedFatalException self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cFeedFatalException]()
        with nogil:
            needed = serializer.cdeserialize[cFeedFatalException](buf, self._cpp_obj.get(), proto)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed


@__cython.auto_pickle(False)
cdef class FeedException(thrift.py3.exceptions.GeneratedError):
    def __init__(FeedException self, *args, **kwargs):
        self._cpp_obj = make_shared[cFeedException]()
        self._fields_setter = _fbthrift_types_fields.__FeedException_FieldsSetter.create(self._cpp_obj.get())
        super().__init__( *args, **kwargs)

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("FeedException", {
          "feedFatalException": deref(self._cpp_obj).feedFatalException_ref().has_value(),
        })

    @staticmethod
    cdef create(shared_ptr[cFeedException] cpp_obj):
        __fbthrift_inst = <FeedException>FeedException.__new__(FeedException, (<bytes>deref(cpp_obj).what()).decode('utf-8'))
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        _builtins.Exception.__init__(__fbthrift_inst, *(v for _, v in __fbthrift_inst))
        return __fbthrift_inst

    @property
    def feedFatalException(self):

        if self.__fbthrift_cached_feedFatalException is None:
            self.__fbthrift_cached_feedFatalException = FeedFatalException.create(__reference_shared_ptr(deref(self._cpp_obj).feedFatalException_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_feedFatalException


    def __hash__(FeedException self):
        return  super().__hash__()

    def __copy__(FeedException self):
        cdef shared_ptr[cFeedException] cpp_obj = make_shared[cFeedException](
            deref(self._cpp_obj)
        )
        return FeedException.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cFeedException](
            self._cpp_obj,
            (<FeedException>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__FeedException()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        ExceptionMetadata[cFeedException].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.FeedException"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cFeedException](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 1



@__cython.auto_pickle(False)
cdef class FeedParseFailure(thrift.py3.types.Struct):
    def __init__(FeedParseFailure self, **kwargs):
        self._cpp_obj = make_shared[cFeedParseFailure]()
        self._fields_setter = _fbthrift_types_fields.__FeedParseFailure_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(FeedParseFailure self, **kwargs):
        if not kwargs:
            return self
        cdef FeedParseFailure __fbthrift_inst = FeedParseFailure.__new__(FeedParseFailure)
        __fbthrift_inst._cpp_obj = make_shared[cFeedParseFailure](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__FeedParseFailure_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("FeedParseFailure", {
          "input": deref(self._cpp_obj).input_ref().has_value(),
          "contexts": deref(self._cpp_obj).contexts_ref().has_value(),
          "description": deref(self._cpp_obj).description_ref().has_value(),
        })

    @staticmethod
    cdef create(shared_ptr[cFeedParseFailure] cpp_obj):
        __fbthrift_inst = <FeedParseFailure>FeedParseFailure.__new__(FeedParseFailure)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def input(self):

        return (<bytes>deref(self._cpp_obj).input_ref().value()).decode('UTF-8')

    @property
    def contexts(self):

        if self.__fbthrift_cached_contexts is None:
            self.__fbthrift_cached_contexts = List__string.create(__reference_shared_ptr(deref(self._cpp_obj).contexts_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_contexts

    @property
    def description(self):

        return (<bytes>deref(self._cpp_obj).description_ref().value()).decode('UTF-8')


    def __hash__(FeedParseFailure self):
        return  super().__hash__()

    def __copy__(FeedParseFailure self):
        cdef shared_ptr[cFeedParseFailure] cpp_obj = make_shared[cFeedParseFailure](
            deref(self._cpp_obj)
        )
        return FeedParseFailure.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cFeedParseFailure](
            self._cpp_obj,
            (<FeedParseFailure>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__FeedParseFailure()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cFeedParseFailure].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.FeedParseFailure"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cFeedParseFailure](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 3

    cdef _fbthrift_iobuf.IOBuf _serialize(FeedParseFailure self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cFeedParseFailure](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(FeedParseFailure self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cFeedParseFailure]()
        with nogil:
            needed = serializer.cdeserialize[cFeedParseFailure](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class FeedTimeoutFailure(thrift.py3.types.Struct):
    def __init__(FeedTimeoutFailure self, **kwargs):
        self._cpp_obj = make_shared[cFeedTimeoutFailure]()
        self._fields_setter = _fbthrift_types_fields.__FeedTimeoutFailure_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(FeedTimeoutFailure self, **kwargs):
        if not kwargs:
            return self
        cdef FeedTimeoutFailure __fbthrift_inst = FeedTimeoutFailure.__new__(FeedTimeoutFailure)
        __fbthrift_inst._cpp_obj = make_shared[cFeedTimeoutFailure](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__FeedTimeoutFailure_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("FeedTimeoutFailure", {
          "message": deref(self._cpp_obj).message_ref().has_value(),
        })

    @staticmethod
    cdef create(shared_ptr[cFeedTimeoutFailure] cpp_obj):
        __fbthrift_inst = <FeedTimeoutFailure>FeedTimeoutFailure.__new__(FeedTimeoutFailure)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def message(self):

        return (<bytes>deref(self._cpp_obj).message_ref().value()).decode('UTF-8')


    def __hash__(FeedTimeoutFailure self):
        return  super().__hash__()

    def __copy__(FeedTimeoutFailure self):
        cdef shared_ptr[cFeedTimeoutFailure] cpp_obj = make_shared[cFeedTimeoutFailure](
            deref(self._cpp_obj)
        )
        return FeedTimeoutFailure.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cFeedTimeoutFailure](
            self._cpp_obj,
            (<FeedTimeoutFailure>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__FeedTimeoutFailure()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cFeedTimeoutFailure].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.FeedTimeoutFailure"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cFeedTimeoutFailure](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 1

    cdef _fbthrift_iobuf.IOBuf _serialize(FeedTimeoutFailure self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cFeedTimeoutFailure](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(FeedTimeoutFailure self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cFeedTimeoutFailure]()
        with nogil:
            needed = serializer.cdeserialize[cFeedTimeoutFailure](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class FeedPartialSuccess(thrift.py3.types.Struct):
    def __init__(FeedPartialSuccess self, **kwargs):
        self._cpp_obj = make_shared[cFeedPartialSuccess]()
        self._fields_setter = _fbthrift_types_fields.__FeedPartialSuccess_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(FeedPartialSuccess self, **kwargs):
        return self

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("FeedPartialSuccess", {
        })

    @staticmethod
    cdef create(shared_ptr[cFeedPartialSuccess] cpp_obj):
        __fbthrift_inst = <FeedPartialSuccess>FeedPartialSuccess.__new__(FeedPartialSuccess)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst


    def __hash__(FeedPartialSuccess self):
        return  super().__hash__()

    def __copy__(FeedPartialSuccess self):
        cdef shared_ptr[cFeedPartialSuccess] cpp_obj = make_shared[cFeedPartialSuccess](
            deref(self._cpp_obj)
        )
        return FeedPartialSuccess.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cFeedPartialSuccess](
            self._cpp_obj,
            (<FeedPartialSuccess>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__FeedPartialSuccess()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cFeedPartialSuccess].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.FeedPartialSuccess"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cFeedPartialSuccess](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 0

    cdef _fbthrift_iobuf.IOBuf _serialize(FeedPartialSuccess self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cFeedPartialSuccess](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(FeedPartialSuccess self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cFeedPartialSuccess]()
        with nogil:
            needed = serializer.cdeserialize[cFeedPartialSuccess](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class FeedCompleteSuccess(thrift.py3.types.Struct):
    def __init__(FeedCompleteSuccess self, **kwargs):
        self._cpp_obj = make_shared[cFeedCompleteSuccess]()
        self._fields_setter = _fbthrift_types_fields.__FeedCompleteSuccess_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(FeedCompleteSuccess self, **kwargs):
        if not kwargs:
            return self
        cdef FeedCompleteSuccess __fbthrift_inst = FeedCompleteSuccess.__new__(FeedCompleteSuccess)
        __fbthrift_inst._cpp_obj = make_shared[cFeedCompleteSuccess](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__FeedCompleteSuccess_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("FeedCompleteSuccess", {
          "leftover": deref(self._cpp_obj).leftover_ref().has_value(),
        })

    @staticmethod
    cdef create(shared_ptr[cFeedCompleteSuccess] cpp_obj):
        __fbthrift_inst = <FeedCompleteSuccess>FeedCompleteSuccess.__new__(FeedCompleteSuccess)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def leftover(self):

        return (<bytes>deref(self._cpp_obj).leftover_ref().value()).decode('UTF-8')


    def __hash__(FeedCompleteSuccess self):
        return  super().__hash__()

    def __copy__(FeedCompleteSuccess self):
        cdef shared_ptr[cFeedCompleteSuccess] cpp_obj = make_shared[cFeedCompleteSuccess](
            deref(self._cpp_obj)
        )
        return FeedCompleteSuccess.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cFeedCompleteSuccess](
            self._cpp_obj,
            (<FeedCompleteSuccess>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__FeedCompleteSuccess()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cFeedCompleteSuccess].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.FeedCompleteSuccess"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cFeedCompleteSuccess](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 1

    cdef _fbthrift_iobuf.IOBuf _serialize(FeedCompleteSuccess self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cFeedCompleteSuccess](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(FeedCompleteSuccess self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cFeedCompleteSuccess]()
        with nogil:
            needed = serializer.cdeserialize[cFeedCompleteSuccess](buf, self._cpp_obj.get(), proto)
        return needed




@__cython.auto_pickle(False)
cdef class FeedResult(thrift.py3.types.Union):
    Type = __FeedResultType

    def __init__(
        self, *,
        FeedParseFailure feedParseFailure=None,
        FeedTimeoutFailure feedTimeoutFailure=None,
        FeedPartialSuccess feedPartialSuccess=None,
        FeedCompleteSuccess feedCompleteSuccess=None
    ):
        self._cpp_obj = __to_shared_ptr(cmove(FeedResult._make_instance(
          NULL,
          feedParseFailure,
          feedTimeoutFailure,
          feedPartialSuccess,
          feedCompleteSuccess,
        )))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return FeedResult()
        if isinstance(value, FeedParseFailure):
            return FeedResult(feedParseFailure=value)
        if isinstance(value, FeedTimeoutFailure):
            return FeedResult(feedTimeoutFailure=value)
        if isinstance(value, FeedPartialSuccess):
            return FeedResult(feedPartialSuccess=value)
        if isinstance(value, FeedCompleteSuccess):
            return FeedResult(feedCompleteSuccess=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cFeedResult] _make_instance(
        cFeedResult* base_instance,
        FeedParseFailure feedParseFailure,
        FeedTimeoutFailure feedTimeoutFailure,
        FeedPartialSuccess feedPartialSuccess,
        FeedCompleteSuccess feedCompleteSuccess
    ) except *:
        cdef unique_ptr[cFeedResult] c_inst = make_unique[cFeedResult]()
        cdef bint any_set = False
        if feedParseFailure is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_feedParseFailure(deref((<FeedParseFailure?> feedParseFailure)._cpp_obj))
            any_set = True
        if feedTimeoutFailure is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_feedTimeoutFailure(deref((<FeedTimeoutFailure?> feedTimeoutFailure)._cpp_obj))
            any_set = True
        if feedPartialSuccess is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_feedPartialSuccess(deref((<FeedPartialSuccess?> feedPartialSuccess)._cpp_obj))
            any_set = True
        if feedCompleteSuccess is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_feedCompleteSuccess(deref((<FeedCompleteSuccess?> feedCompleteSuccess)._cpp_obj))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return cmove(c_inst)

    @staticmethod
    cdef create(shared_ptr[cFeedResult] cpp_obj):
        __fbthrift_inst = <FeedResult>FeedResult.__new__(FeedResult)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        __fbthrift_inst._load_cache()
        return __fbthrift_inst

    @property
    def feedParseFailure(self):
        if self.type.value != 1:
            raise TypeError(f'Union contains a value of type {self.type.name}, not feedParseFailure')
        return self.value

    @property
    def feedTimeoutFailure(self):
        if self.type.value != 2:
            raise TypeError(f'Union contains a value of type {self.type.name}, not feedTimeoutFailure')
        return self.value

    @property
    def feedPartialSuccess(self):
        if self.type.value != 3:
            raise TypeError(f'Union contains a value of type {self.type.name}, not feedPartialSuccess')
        return self.value

    @property
    def feedCompleteSuccess(self):
        if self.type.value != 4:
            raise TypeError(f'Union contains a value of type {self.type.name}, not feedCompleteSuccess')
        return self.value


    def __hash__(FeedResult self):
        return  super().__hash__()

    cdef _load_cache(FeedResult self):
        self.type = FeedResult.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            self.value = FeedParseFailure.create(make_shared[cFeedParseFailure](deref(self._cpp_obj).get_feedParseFailure()))
        elif type == 2:
            self.value = FeedTimeoutFailure.create(make_shared[cFeedTimeoutFailure](deref(self._cpp_obj).get_feedTimeoutFailure()))
        elif type == 3:
            self.value = FeedPartialSuccess.create(make_shared[cFeedPartialSuccess](deref(self._cpp_obj).get_feedPartialSuccess()))
        elif type == 4:
            self.value = FeedCompleteSuccess.create(make_shared[cFeedCompleteSuccess](deref(self._cpp_obj).get_feedCompleteSuccess()))

    def __copy__(FeedResult self):
        cdef shared_ptr[cFeedResult] cpp_obj = make_shared[cFeedResult](
            deref(self._cpp_obj)
        )
        return FeedResult.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cFeedResult](
            self._cpp_obj,
            (<FeedResult>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__FeedResult()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cFeedResult].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.FeedResult"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cFeedResult](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 4

    cdef _fbthrift_iobuf.IOBuf _serialize(FeedResult self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cFeedResult](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(FeedResult self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cFeedResult]()
        with nogil:
            needed = serializer.cdeserialize[cFeedResult](buf, self._cpp_obj.get(), proto)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed


@__cython.auto_pickle(False)
cdef class BatchFeedResult(thrift.py3.types.Struct):
    def __init__(BatchFeedResult self, **kwargs):
        self._cpp_obj = make_shared[cBatchFeedResult]()
        self._fields_setter = _fbthrift_types_fields.__BatchFeedResult_FieldsSetter.create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(BatchFeedResult self, **kwargs):
        if not kwargs:
            return self
        cdef BatchFeedResult __fbthrift_inst = BatchFeedResult.__new__(BatchFeedResult)
        __fbthrift_inst._cpp_obj = make_shared[cBatchFeedResult](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__BatchFeedResult_FieldsSetter.create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("BatchFeedResult", {
          "batchId": deref(self._cpp_obj).batchId_ref().has_value(),
          "topToken": deref(self._cpp_obj).topToken_ref().has_value(),
          "feedResult": deref(self._cpp_obj).feedResult_ref().has_value(),
        })

    @staticmethod
    cdef create(shared_ptr[cBatchFeedResult] cpp_obj):
        __fbthrift_inst = <BatchFeedResult>BatchFeedResult.__new__(BatchFeedResult)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    @property
    def batchId(self):

        return deref(self._cpp_obj).batchId_ref().value()

    @property
    def topToken(self):

        return deref(self._cpp_obj).topToken_ref().value()

    @property
    def feedResult(self):

        if self.__fbthrift_cached_feedResult is None:
            self.__fbthrift_cached_feedResult = FeedResult.create(__reference_shared_ptr(deref(self._cpp_obj).feedResult_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_feedResult


    def __hash__(BatchFeedResult self):
        return  super().__hash__()

    def __copy__(BatchFeedResult self):
        cdef shared_ptr[cBatchFeedResult] cpp_obj = make_shared[cBatchFeedResult](
            deref(self._cpp_obj)
        )
        return BatchFeedResult.create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cBatchFeedResult](
            self._cpp_obj,
            (<BatchFeedResult>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__BatchFeedResult()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cBatchFeedResult].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "picard.BatchFeedResult"

    cdef __cstring_view _fbthrift_get_field_name_by_index(self, size_t idx):
        return __get_field_name_by_index[cBatchFeedResult](idx)

    def __cinit__(self):
        self._fbthrift_struct_size = 3

    cdef _fbthrift_iobuf.IOBuf _serialize(BatchFeedResult self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cBatchFeedResult](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _deserialize(BatchFeedResult self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cBatchFeedResult]()
        with nogil:
            needed = serializer.cdeserialize[cBatchFeedResult](buf, self._cpp_obj.get(), proto)
        return needed


@__cython.auto_pickle(False)
cdef class List__i64(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__i64):
            self._cpp_obj = (<List__i64> items)._cpp_obj
        else:
            self._cpp_obj = List__i64._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cint64_t]] c_items):
        __fbthrift_inst = <List__i64>List__i64.__new__(List__i64)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__i64 self):
        cdef shared_ptr[vector[cint64_t]] cpp_obj = make_shared[vector[cint64_t]](
            deref(self._cpp_obj)
        )
        return List__i64.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cint64_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cint64_t]] c_inst = make_shared[vector[cint64_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint64_t> item
                deref(c_inst).push_back(item)
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__i64.create(
            __list_slice[vector[cint64_t]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef cint64_t citem = 0
        __list_getitem(self._cpp_obj, index, citem)
        return citem

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, int):
            return item

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef cint64_t citem = item
        cdef std_libcpp.optional[size_t] found = __list_index[vector[cint64_t]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef cint64_t citem = item
        return __list_count[vector[cint64_t]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__i64()


Sequence.register(List__i64)

@__cython.auto_pickle(False)
cdef class List__List__i64(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__List__i64):
            self._cpp_obj = (<List__List__i64> items)._cpp_obj
        else:
            self._cpp_obj = List__List__i64._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[vector[cint64_t]]] c_items):
        __fbthrift_inst = <List__List__i64>List__List__i64.__new__(List__List__i64)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__List__i64 self):
        cdef shared_ptr[vector[vector[cint64_t]]] cpp_obj = make_shared[vector[vector[cint64_t]]](
            deref(self._cpp_obj)
        )
        return List__List__i64.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[vector[cint64_t]]] _make_instance(object items) except *:
        cdef shared_ptr[vector[vector[cint64_t]]] c_inst = make_shared[vector[vector[cint64_t]]]()
        if items is not None:
            for item in items:
                if item is None:
                    raise TypeError("None is not of the type _typing.Sequence[int]")
                if not isinstance(item, List__i64):
                    item = List__i64(item)
                deref(c_inst).push_back(deref((<List__i64>item)._cpp_obj))
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__List__i64.create(
            __list_slice[vector[vector[cint64_t]]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef shared_ptr[vector[cint64_t]] citem
        __list_getitem(self._cpp_obj, index, citem)
        return List__i64.create(citem)

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, List__i64):
            return item
        try:
            return List__i64(item)
        except:
            pass

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef vector[cint64_t] citem = deref((<List__i64>item)._cpp_obj)
        cdef std_libcpp.optional[size_t] found = __list_index[vector[vector[cint64_t]]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef vector[cint64_t] citem = deref((<List__i64>item)._cpp_obj)
        return __list_count[vector[vector[cint64_t]]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__List__i64()


Sequence.register(List__List__i64)

@__cython.auto_pickle(False)
cdef class List__BatchFeedResult(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__BatchFeedResult):
            self._cpp_obj = (<List__BatchFeedResult> items)._cpp_obj
        else:
            self._cpp_obj = List__BatchFeedResult._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[cBatchFeedResult]] c_items):
        __fbthrift_inst = <List__BatchFeedResult>List__BatchFeedResult.__new__(List__BatchFeedResult)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__BatchFeedResult self):
        cdef shared_ptr[vector[cBatchFeedResult]] cpp_obj = make_shared[vector[cBatchFeedResult]](
            deref(self._cpp_obj)
        )
        return List__BatchFeedResult.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cBatchFeedResult]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cBatchFeedResult]] c_inst = make_shared[vector[cBatchFeedResult]]()
        if items is not None:
            for item in items:
                if not isinstance(item, BatchFeedResult):
                    raise TypeError(f"{item!r} is not of type 'BatchFeedResult'")
                deref(c_inst).push_back(deref((<BatchFeedResult>item)._cpp_obj))
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__BatchFeedResult.create(
            __list_slice[vector[cBatchFeedResult]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef shared_ptr[cBatchFeedResult] citem
        __list_getitem(self._cpp_obj, index, citem)
        return BatchFeedResult.create(citem)

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, BatchFeedResult):
            return item

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef cBatchFeedResult citem = deref((<BatchFeedResult>item)._cpp_obj)
        cdef std_libcpp.optional[size_t] found = __list_index[vector[cBatchFeedResult]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef cBatchFeedResult citem = deref((<BatchFeedResult>item)._cpp_obj)
        return __list_count[vector[cBatchFeedResult]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__BatchFeedResult()


Sequence.register(List__BatchFeedResult)

@__cython.auto_pickle(False)
cdef class Map__string_string(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_string):
            self._cpp_obj = (<Map__string_string> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,string]] c_items):
        __fbthrift_inst = <Map__string_string>Map__string_string.__new__(Map__string_string)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_string self):
        cdef shared_ptr[cmap[string,string]] cpp_obj = make_shared[cmap[string,string]](
            deref(self._cpp_obj)
        )
        return Map__string_string.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,string]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,string]] c_inst = make_shared[cmap[string,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst)[key.encode('UTF-8')] = item.encode('UTF-8')
        return c_inst

    cdef _check_key_type(self, key):
        if not self or key is None:
            return
        if isinstance(key, str):
            return key

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        key = self._check_key_type(key)
        if key is None:
            raise err
        cdef string ckey = key.encode('UTF-8')
        if not __map_contains(self._cpp_obj, ckey):
            raise err
        cdef string citem
        __map_getitem(self._cpp_obj, ckey, citem)
        return bytes(citem).decode('UTF-8')

    def __iter__(self):
        if not self:
            return
        cdef __map_iter[cmap[string,string]] itr = __map_iter[cmap[string,string]](self._cpp_obj)
        cdef string citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextKey(self._cpp_obj, citem)
            yield bytes(citem).decode('UTF-8')

    def __contains__(self, key):
        key = self._check_key_type(key)
        if key is None:
            return False
        cdef string ckey = key.encode('UTF-8')
        return __map_contains(self._cpp_obj, ckey)

    def values(self):
        if not self:
            return
        cdef __map_iter[cmap[string,string]] itr = __map_iter[cmap[string,string]](self._cpp_obj)
        cdef string citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextValue(self._cpp_obj, citem)
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            return
        cdef __map_iter[cmap[string,string]] itr = __map_iter[cmap[string,string]](self._cpp_obj)
        cdef string ckey
        cdef string citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextItem(self._cpp_obj, ckey, citem)
            yield (ckey.data().decode('UTF-8'), bytes(citem).decode('UTF-8'))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_string()

Mapping.register(Map__string_string)

@__cython.auto_pickle(False)
cdef class Map__string_ColumnType(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_ColumnType):
            self._cpp_obj = (<Map__string_ColumnType> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_ColumnType._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,cColumnType]] c_items):
        __fbthrift_inst = <Map__string_ColumnType>Map__string_ColumnType.__new__(Map__string_ColumnType)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_ColumnType self):
        cdef shared_ptr[cmap[string,cColumnType]] cpp_obj = make_shared[cmap[string,cColumnType]](
            deref(self._cpp_obj)
        )
        return Map__string_ColumnType.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,cColumnType]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,cColumnType]] c_inst = make_shared[cmap[string,cColumnType]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if not isinstance(item, ColumnType):
                    raise TypeError(f"{item!r} is not of type ColumnType")

                deref(c_inst)[key.encode('UTF-8')] = <cColumnType><int>item
        return c_inst

    cdef _check_key_type(self, key):
        if not self or key is None:
            return
        if isinstance(key, str):
            return key

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        key = self._check_key_type(key)
        if key is None:
            raise err
        cdef string ckey = key.encode('UTF-8')
        if not __map_contains(self._cpp_obj, ckey):
            raise err
        cdef cColumnType citem
        __map_getitem(self._cpp_obj, ckey, citem)
        return translate_cpp_enum_to_python(ColumnType, <int> citem)

    def __iter__(self):
        if not self:
            return
        cdef __map_iter[cmap[string,cColumnType]] itr = __map_iter[cmap[string,cColumnType]](self._cpp_obj)
        cdef string citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextKey(self._cpp_obj, citem)
            yield bytes(citem).decode('UTF-8')

    def __contains__(self, key):
        key = self._check_key_type(key)
        if key is None:
            return False
        cdef string ckey = key.encode('UTF-8')
        return __map_contains(self._cpp_obj, ckey)

    def values(self):
        if not self:
            return
        cdef __map_iter[cmap[string,cColumnType]] itr = __map_iter[cmap[string,cColumnType]](self._cpp_obj)
        cdef cColumnType citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextValue(self._cpp_obj, citem)
            yield translate_cpp_enum_to_python(ColumnType, <int> citem)

    def items(self):
        if not self:
            return
        cdef __map_iter[cmap[string,cColumnType]] itr = __map_iter[cmap[string,cColumnType]](self._cpp_obj)
        cdef string ckey
        cdef cColumnType citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextItem(self._cpp_obj, ckey, citem)
            yield (ckey.data().decode('UTF-8'), translate_cpp_enum_to_python(ColumnType, <int> citem))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_ColumnType()

Mapping.register(Map__string_ColumnType)

@__cython.auto_pickle(False)
cdef class List__string(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__string):
            self._cpp_obj = (<List__string> items)._cpp_obj
        else:
            self._cpp_obj = List__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[vector[string]] c_items):
        __fbthrift_inst = <List__string>List__string.__new__(List__string)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__string self):
        cdef shared_ptr[vector[string]] cpp_obj = make_shared[vector[string]](
            deref(self._cpp_obj)
        )
        return List__string.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[string]] _make_instance(object items) except *:
        cdef shared_ptr[vector[string]] c_inst = make_shared[vector[string]]()
        if items is not None:
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).push_back(item.encode('UTF-8'))
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__string.create(
            __list_slice[vector[string]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef string citem
        __list_getitem(self._cpp_obj, index, citem)
        return bytes(citem).decode('UTF-8')

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, str):
            return item

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef string citem = item.encode('UTF-8')
        cdef std_libcpp.optional[size_t] found = __list_index[vector[string]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef string citem = item.encode('UTF-8')
        return __list_count[vector[string]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__string()


Sequence.register(List__string)

@__cython.auto_pickle(False)
cdef class Map__string_List__string(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__string_List__string):
            self._cpp_obj = (<Map__string_List__string> items)._cpp_obj
        else:
            self._cpp_obj = Map__string_List__string._make_instance(items)

    @staticmethod
    cdef create(shared_ptr[cmap[string,vector[string]]] c_items):
        __fbthrift_inst = <Map__string_List__string>Map__string_List__string.__new__(Map__string_List__string)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Map__string_List__string self):
        cdef shared_ptr[cmap[string,vector[string]]] cpp_obj = make_shared[cmap[string,vector[string]]](
            deref(self._cpp_obj)
        )
        return Map__string_List__string.create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[string,vector[string]]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[string,vector[string]]] c_inst = make_shared[cmap[string,vector[string]]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, str):
                    raise TypeError(f"{key!r} is not of type str")
                if item is None:
                    raise TypeError("None is not of type _typing.Sequence[str]")
                if not isinstance(item, List__string):
                    item = List__string(item)

                deref(c_inst)[key.encode('UTF-8')] = deref((<List__string>item)._cpp_obj)
        return c_inst

    cdef _check_key_type(self, key):
        if not self or key is None:
            return
        if isinstance(key, str):
            return key

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        key = self._check_key_type(key)
        if key is None:
            raise err
        cdef string ckey = key.encode('UTF-8')
        if not __map_contains(self._cpp_obj, ckey):
            raise err
        cdef shared_ptr[vector[string]] citem
        __map_getitem(self._cpp_obj, ckey, citem)
        return List__string.create(citem)

    def __iter__(self):
        if not self:
            return
        cdef __map_iter[cmap[string,vector[string]]] itr = __map_iter[cmap[string,vector[string]]](self._cpp_obj)
        cdef string citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextKey(self._cpp_obj, citem)
            yield bytes(citem).decode('UTF-8')

    def __contains__(self, key):
        key = self._check_key_type(key)
        if key is None:
            return False
        cdef string ckey = key.encode('UTF-8')
        return __map_contains(self._cpp_obj, ckey)

    def values(self):
        if not self:
            return
        cdef __map_iter[cmap[string,vector[string]]] itr = __map_iter[cmap[string,vector[string]]](self._cpp_obj)
        cdef shared_ptr[vector[string]] citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextValue(self._cpp_obj, citem)
            yield List__string.create(citem)

    def items(self):
        if not self:
            return
        cdef __map_iter[cmap[string,vector[string]]] itr = __map_iter[cmap[string,vector[string]]](self._cpp_obj)
        cdef string ckey
        cdef shared_ptr[vector[string]] citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextItem(self._cpp_obj, ckey, citem)
            yield (ckey.data().decode('UTF-8'), List__string.create(citem))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__string_List__string()

Mapping.register(Map__string_List__string)

ColumnId = str
TableId = str
DBId = str
Token = int
InputIds = List__i64
BatchId = int
