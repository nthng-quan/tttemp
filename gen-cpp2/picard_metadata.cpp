/**
 * Autogenerated by Thrift for picard.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <thrift/lib/cpp2/gen/module_metadata_cpp.h>
#include "picard_metadata.h"

namespace apache {
namespace thrift {
namespace detail {
namespace md {
using ThriftMetadata = ::apache::thrift::metadata::ThriftMetadata;
using ThriftPrimitiveType = ::apache::thrift::metadata::ThriftPrimitiveType;
using ThriftType = ::apache::thrift::metadata::ThriftType;
using ThriftService = ::apache::thrift::metadata::ThriftService;
using ThriftServiceContext = ::apache::thrift::metadata::ThriftServiceContext;
using ThriftFunctionGenerator = void (*)(ThriftMetadata&, ThriftService&);

void EnumMetadata<::cpp2::ColumnType>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("picard.ColumnType", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "picard.ColumnType";
  using EnumTraits = TEnumTraits<::cpp2::ColumnType>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}
void EnumMetadata<::cpp2::Mode>::gen(ThriftMetadata& metadata) {
  auto res = metadata.enums_ref()->emplace("picard.Mode", ::apache::thrift::metadata::ThriftEnum{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftEnum& enum_metadata = res.first->second;
  enum_metadata.name_ref() = "picard.Mode";
  using EnumTraits = TEnumTraits<::cpp2::Mode>;
  for (std::size_t i = 0; i < EnumTraits::size; ++i) {
    enum_metadata.elements_ref()->emplace(static_cast<int32_t>(EnumTraits::values[i]), EnumTraits::names[i].str());
  }
}

const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::SQLSchema>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("picard.SQLSchema", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& picard_SQLSchema = res.first->second;
  picard_SQLSchema.name_ref() = "picard.SQLSchema";
  picard_SQLSchema.is_union_ref() = false;
  static const EncodedThriftField
  picard_SQLSchema_fields[] = {
    std::make_tuple(1, "columnNames", false, std::make_unique<Map>(std::make_unique<Typedef>("picard.ColumnId", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "columnTypes", false, std::make_unique<Map>(std::make_unique<Typedef>("picard.ColumnId", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::make_unique<Enum< ::cpp2::ColumnType>>("picard.ColumnType")), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "tableNames", false, std::make_unique<Map>(std::make_unique<Typedef>("picard.TableId", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "columnToTable", false, std::make_unique<Map>(std::make_unique<Typedef>("picard.ColumnId", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::make_unique<Typedef>("picard.TableId", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(5, "tableToColumns", false, std::make_unique<Map>(std::make_unique<Typedef>("picard.TableId", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::make_unique<List>(std::make_unique<Typedef>("picard.ColumnId", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(6, "foreignKeys", false, std::make_unique<Map>(std::make_unique<Typedef>("picard.ColumnId", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::make_unique<Typedef>("picard.ColumnId", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE))), std::vector<ThriftConstStruct>{}),
    std::make_tuple(7, "primaryKeys", false, std::make_unique<List>(std::make_unique<Typedef>("picard.ColumnId", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE))), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_SQLSchema_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    picard_SQLSchema.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::RegisterSQLSchemaException>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("picard.RegisterSQLSchemaException", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& picard_RegisterSQLSchemaException = res.first->second;
  picard_RegisterSQLSchemaException.name_ref() = "picard.RegisterSQLSchemaException";
  picard_RegisterSQLSchemaException.is_union_ref() = false;
  static const EncodedThriftField
  picard_RegisterSQLSchemaException_fields[] = {
    std::make_tuple(1, "dbId", false, std::make_unique<Typedef>("picard.DBId", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "message", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_RegisterSQLSchemaException_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    picard_RegisterSQLSchemaException.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::RegisterTokenizerException>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("picard.RegisterTokenizerException", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& picard_RegisterTokenizerException = res.first->second;
  picard_RegisterTokenizerException.name_ref() = "picard.RegisterTokenizerException";
  picard_RegisterTokenizerException.is_union_ref() = false;
  static const EncodedThriftField
  picard_RegisterTokenizerException_fields[] = {
    std::make_tuple(1, "message", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_RegisterTokenizerException_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    picard_RegisterTokenizerException.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::TokenizerNotRegisteredException>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("picard.TokenizerNotRegisteredException", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& picard_TokenizerNotRegisteredException = res.first->second;
  picard_TokenizerNotRegisteredException.name_ref() = "picard.TokenizerNotRegisteredException";
  picard_TokenizerNotRegisteredException.is_union_ref() = false;
  static const EncodedThriftField
  picard_TokenizerNotRegisteredException_fields[] = {
    std::make_tuple(1, "message", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_TokenizerNotRegisteredException_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    picard_TokenizerNotRegisteredException.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::TokenizerPrefixException>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("picard.TokenizerPrefixException", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& picard_TokenizerPrefixException = res.first->second;
  picard_TokenizerPrefixException.name_ref() = "picard.TokenizerPrefixException";
  picard_TokenizerPrefixException.is_union_ref() = false;
  static const EncodedThriftField
  picard_TokenizerPrefixException_fields[] = {
    std::make_tuple(1, "message", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_TokenizerPrefixException_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    picard_TokenizerPrefixException.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::ModeException>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("picard.ModeException", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& picard_ModeException = res.first->second;
  picard_ModeException.name_ref() = "picard.ModeException";
  picard_ModeException.is_union_ref() = false;
  static const EncodedThriftField
  picard_ModeException_fields[] = {
    std::make_tuple(1, "message", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_ModeException_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    picard_ModeException.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::FeedFatalException>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("picard.FeedFatalException", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& picard_FeedFatalException = res.first->second;
  picard_FeedFatalException.name_ref() = "picard.FeedFatalException";
  picard_FeedFatalException.is_union_ref() = true;
  static const EncodedThriftField
  picard_FeedFatalException_fields[] = {
    std::make_tuple(1, "tokenizerNotRegisteredException", false, std::make_unique<Struct< ::cpp2::TokenizerNotRegisteredException>>("picard.TokenizerNotRegisteredException"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "tokenizerPrefixException", false, std::make_unique<Struct< ::cpp2::TokenizerPrefixException>>("picard.TokenizerPrefixException"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "modeException", false, std::make_unique<Struct< ::cpp2::ModeException>>("picard.ModeException"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_FeedFatalException_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    picard_FeedFatalException.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::FeedException>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("picard.FeedException", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& picard_FeedException = res.first->second;
  picard_FeedException.name_ref() = "picard.FeedException";
  picard_FeedException.is_union_ref() = false;
  static const EncodedThriftField
  picard_FeedException_fields[] = {
    std::make_tuple(1, "feedFatalException", false, std::make_unique<Union< ::cpp2::FeedFatalException>>("picard.FeedFatalException"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_FeedException_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    picard_FeedException.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::FeedParseFailure>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("picard.FeedParseFailure", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& picard_FeedParseFailure = res.first->second;
  picard_FeedParseFailure.name_ref() = "picard.FeedParseFailure";
  picard_FeedParseFailure.is_union_ref() = false;
  static const EncodedThriftField
  picard_FeedParseFailure_fields[] = {
    std::make_tuple(1, "input", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "contexts", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "description", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_FeedParseFailure_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    picard_FeedParseFailure.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::FeedTimeoutFailure>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("picard.FeedTimeoutFailure", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& picard_FeedTimeoutFailure = res.first->second;
  picard_FeedTimeoutFailure.name_ref() = "picard.FeedTimeoutFailure";
  picard_FeedTimeoutFailure.is_union_ref() = false;
  static const EncodedThriftField
  picard_FeedTimeoutFailure_fields[] = {
    std::make_tuple(1, "message", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_FeedTimeoutFailure_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    picard_FeedTimeoutFailure.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::FeedPartialSuccess>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("picard.FeedPartialSuccess", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& picard_FeedPartialSuccess = res.first->second;
  picard_FeedPartialSuccess.name_ref() = "picard.FeedPartialSuccess";
  picard_FeedPartialSuccess.is_union_ref() = false;
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::FeedCompleteSuccess>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("picard.FeedCompleteSuccess", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& picard_FeedCompleteSuccess = res.first->second;
  picard_FeedCompleteSuccess.name_ref() = "picard.FeedCompleteSuccess";
  picard_FeedCompleteSuccess.is_union_ref() = false;
  static const EncodedThriftField
  picard_FeedCompleteSuccess_fields[] = {
    std::make_tuple(1, "leftover", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_FeedCompleteSuccess_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    picard_FeedCompleteSuccess.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::FeedResult>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("picard.FeedResult", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& picard_FeedResult = res.first->second;
  picard_FeedResult.name_ref() = "picard.FeedResult";
  picard_FeedResult.is_union_ref() = true;
  static const EncodedThriftField
  picard_FeedResult_fields[] = {
    std::make_tuple(1, "feedParseFailure", false, std::make_unique<Struct< ::cpp2::FeedParseFailure>>("picard.FeedParseFailure"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "feedTimeoutFailure", false, std::make_unique<Struct< ::cpp2::FeedTimeoutFailure>>("picard.FeedTimeoutFailure"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "feedPartialSuccess", false, std::make_unique<Struct< ::cpp2::FeedPartialSuccess>>("picard.FeedPartialSuccess"), std::vector<ThriftConstStruct>{}),
    std::make_tuple(4, "feedCompleteSuccess", false, std::make_unique<Struct< ::cpp2::FeedCompleteSuccess>>("picard.FeedCompleteSuccess"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_FeedResult_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    picard_FeedResult.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::cpp2::BatchFeedResult>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("picard.BatchFeedResult", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& picard_BatchFeedResult = res.first->second;
  picard_BatchFeedResult.name_ref() = "picard.BatchFeedResult";
  picard_BatchFeedResult.is_union_ref() = false;
  static const EncodedThriftField
  picard_BatchFeedResult_fields[] = {
    std::make_tuple(1, "batchId", false, std::make_unique<Typedef>("picard.BatchId", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "topToken", false, std::make_unique<Typedef>("picard.Token", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(3, "feedResult", false, std::make_unique<Union< ::cpp2::FeedResult>>("picard.FeedResult"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_BatchFeedResult_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = std::get<4>(f);
    picard_BatchFeedResult.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}

void ExceptionMetadata<::cpp2::RegisterSQLSchemaException>::gen(ThriftMetadata& metadata) {
  auto res = metadata.exceptions_ref()->emplace("picard.RegisterSQLSchemaException", ::apache::thrift::metadata::ThriftException{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftException& picard_RegisterSQLSchemaException = res.first->second;
  picard_RegisterSQLSchemaException.name_ref() = "picard.RegisterSQLSchemaException";
  static const EncodedThriftField
  picard_RegisterSQLSchemaException_fields[] = {
    std::make_tuple(1, "dbId", false, std::make_unique<Typedef>("picard.DBId", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{}),
    std::make_tuple(2, "message", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_RegisterSQLSchemaException_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    picard_RegisterSQLSchemaException.fields_ref()->push_back(std::move(field));
  }
}
void ExceptionMetadata<::cpp2::RegisterTokenizerException>::gen(ThriftMetadata& metadata) {
  auto res = metadata.exceptions_ref()->emplace("picard.RegisterTokenizerException", ::apache::thrift::metadata::ThriftException{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftException& picard_RegisterTokenizerException = res.first->second;
  picard_RegisterTokenizerException.name_ref() = "picard.RegisterTokenizerException";
  static const EncodedThriftField
  picard_RegisterTokenizerException_fields[] = {
    std::make_tuple(1, "message", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_RegisterTokenizerException_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    picard_RegisterTokenizerException.fields_ref()->push_back(std::move(field));
  }
}
void ExceptionMetadata<::cpp2::FeedException>::gen(ThriftMetadata& metadata) {
  auto res = metadata.exceptions_ref()->emplace("picard.FeedException", ::apache::thrift::metadata::ThriftException{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftException& picard_FeedException = res.first->second;
  picard_FeedException.name_ref() = "picard.FeedException";
  static const EncodedThriftField
  picard_FeedException_fields[] = {
    std::make_tuple(1, "feedFatalException", false, std::make_unique<Union< ::cpp2::FeedFatalException>>("picard.FeedFatalException"), std::vector<ThriftConstStruct>{}),
  };
  for (const auto& f : picard_FeedException_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = std::get<0>(f);
    field.name_ref() = std::get<1>(f);
    field.is_optional_ref() = std::get<2>(f);
    std::get<3>(f)->writeAndGenType(*field.type_ref(), metadata);
    picard_FeedException.fields_ref()->push_back(std::move(field));
  }
}
void ServiceMetadata<::cpp2::PicardSvIf>::gen_registerSQLSchema(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "registerSQLSchema";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_VOID_TYPE);
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField picard_Picard_registerSQLSchema_dbId_1;
  picard_Picard_registerSQLSchema_dbId_1.id_ref() = 1;
  picard_Picard_registerSQLSchema_dbId_1.name_ref() = "dbId";
  picard_Picard_registerSQLSchema_dbId_1.is_optional_ref() = false;
  auto picard_Picard_registerSQLSchema_dbId_1_type = std::make_unique<Typedef>("picard.DBId", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE));
  picard_Picard_registerSQLSchema_dbId_1_type->writeAndGenType(*picard_Picard_registerSQLSchema_dbId_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(picard_Picard_registerSQLSchema_dbId_1));
  ::apache::thrift::metadata::ThriftField picard_Picard_registerSQLSchema_sqlSchema_2;
  picard_Picard_registerSQLSchema_sqlSchema_2.id_ref() = 2;
  picard_Picard_registerSQLSchema_sqlSchema_2.name_ref() = "sqlSchema";
  picard_Picard_registerSQLSchema_sqlSchema_2.is_optional_ref() = false;
  auto picard_Picard_registerSQLSchema_sqlSchema_2_type = std::make_unique<Struct< ::cpp2::SQLSchema>>("picard.SQLSchema");
  picard_Picard_registerSQLSchema_sqlSchema_2_type->writeAndGenType(*picard_Picard_registerSQLSchema_sqlSchema_2.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(picard_Picard_registerSQLSchema_sqlSchema_2));
  ::apache::thrift::metadata::ThriftField picard_Picard_registerSQLSchema_fail_1;
  picard_Picard_registerSQLSchema_fail_1.id_ref() = 1;
  picard_Picard_registerSQLSchema_fail_1.name_ref() = "fail";
  picard_Picard_registerSQLSchema_fail_1.is_optional_ref() = false;
  auto picard_Picard_registerSQLSchema_fail_1_type = std::make_unique<Struct< ::cpp2::RegisterSQLSchemaException>>("picard.RegisterSQLSchemaException");
  picard_Picard_registerSQLSchema_fail_1_type->writeAndGenType(*picard_Picard_registerSQLSchema_fail_1.type_ref(), metadata);
  func.exceptions_ref()->push_back(std::move(picard_Picard_registerSQLSchema_fail_1));
  ExceptionMetadata< ::cpp2::RegisterSQLSchemaException>::gen(metadata);
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::cpp2::PicardSvIf>::gen_registerTokenizer(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "registerTokenizer";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_VOID_TYPE);
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField picard_Picard_registerTokenizer_jsonConfig_1;
  picard_Picard_registerTokenizer_jsonConfig_1.id_ref() = 1;
  picard_Picard_registerTokenizer_jsonConfig_1.name_ref() = "jsonConfig";
  picard_Picard_registerTokenizer_jsonConfig_1.is_optional_ref() = false;
  auto picard_Picard_registerTokenizer_jsonConfig_1_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE);
  picard_Picard_registerTokenizer_jsonConfig_1_type->writeAndGenType(*picard_Picard_registerTokenizer_jsonConfig_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(picard_Picard_registerTokenizer_jsonConfig_1));
  ::apache::thrift::metadata::ThriftField picard_Picard_registerTokenizer_fail_1;
  picard_Picard_registerTokenizer_fail_1.id_ref() = 1;
  picard_Picard_registerTokenizer_fail_1.name_ref() = "fail";
  picard_Picard_registerTokenizer_fail_1.is_optional_ref() = false;
  auto picard_Picard_registerTokenizer_fail_1_type = std::make_unique<Struct< ::cpp2::RegisterTokenizerException>>("picard.RegisterTokenizerException");
  picard_Picard_registerTokenizer_fail_1_type->writeAndGenType(*picard_Picard_registerTokenizer_fail_1.type_ref(), metadata);
  func.exceptions_ref()->push_back(std::move(picard_Picard_registerTokenizer_fail_1));
  ExceptionMetadata< ::cpp2::RegisterTokenizerException>::gen(metadata);
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::cpp2::PicardSvIf>::gen_feed(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "feed";
  auto func_ret_type = std::make_unique<Union< ::cpp2::FeedResult>>("picard.FeedResult");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField picard_Picard_feed_inputIds_1;
  picard_Picard_feed_inputIds_1.id_ref() = 1;
  picard_Picard_feed_inputIds_1.name_ref() = "inputIds";
  picard_Picard_feed_inputIds_1.is_optional_ref() = false;
  auto picard_Picard_feed_inputIds_1_type = std::make_unique<Typedef>("picard.InputIds", std::make_unique<List>(std::make_unique<Typedef>("picard.Token", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE))));
  picard_Picard_feed_inputIds_1_type->writeAndGenType(*picard_Picard_feed_inputIds_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(picard_Picard_feed_inputIds_1));
  ::apache::thrift::metadata::ThriftField picard_Picard_feed_token_2;
  picard_Picard_feed_token_2.id_ref() = 2;
  picard_Picard_feed_token_2.name_ref() = "token";
  picard_Picard_feed_token_2.is_optional_ref() = false;
  auto picard_Picard_feed_token_2_type = std::make_unique<Typedef>("picard.Token", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE));
  picard_Picard_feed_token_2_type->writeAndGenType(*picard_Picard_feed_token_2.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(picard_Picard_feed_token_2));
  ::apache::thrift::metadata::ThriftField picard_Picard_feed_mode_3;
  picard_Picard_feed_mode_3.id_ref() = 3;
  picard_Picard_feed_mode_3.name_ref() = "mode";
  picard_Picard_feed_mode_3.is_optional_ref() = false;
  auto picard_Picard_feed_mode_3_type = std::make_unique<Enum< ::cpp2::Mode>>("picard.Mode");
  picard_Picard_feed_mode_3_type->writeAndGenType(*picard_Picard_feed_mode_3.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(picard_Picard_feed_mode_3));
  ::apache::thrift::metadata::ThriftField picard_Picard_feed_fail_1;
  picard_Picard_feed_fail_1.id_ref() = 1;
  picard_Picard_feed_fail_1.name_ref() = "fail";
  picard_Picard_feed_fail_1.is_optional_ref() = false;
  auto picard_Picard_feed_fail_1_type = std::make_unique<Struct< ::cpp2::FeedException>>("picard.FeedException");
  picard_Picard_feed_fail_1_type->writeAndGenType(*picard_Picard_feed_fail_1.type_ref(), metadata);
  func.exceptions_ref()->push_back(std::move(picard_Picard_feed_fail_1));
  ExceptionMetadata< ::cpp2::FeedException>::gen(metadata);
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::cpp2::PicardSvIf>::gen_batchFeed(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "batchFeed";
  auto func_ret_type = std::make_unique<List>(std::make_unique<Struct< ::cpp2::BatchFeedResult>>("picard.BatchFeedResult"));
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField picard_Picard_batchFeed_inputIds_1;
  picard_Picard_batchFeed_inputIds_1.id_ref() = 1;
  picard_Picard_batchFeed_inputIds_1.name_ref() = "inputIds";
  picard_Picard_batchFeed_inputIds_1.is_optional_ref() = false;
  auto picard_Picard_batchFeed_inputIds_1_type = std::make_unique<List>(std::make_unique<Typedef>("picard.InputIds", std::make_unique<List>(std::make_unique<Typedef>("picard.Token", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE)))));
  picard_Picard_batchFeed_inputIds_1_type->writeAndGenType(*picard_Picard_batchFeed_inputIds_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(picard_Picard_batchFeed_inputIds_1));
  ::apache::thrift::metadata::ThriftField picard_Picard_batchFeed_topTokens_2;
  picard_Picard_batchFeed_topTokens_2.id_ref() = 2;
  picard_Picard_batchFeed_topTokens_2.name_ref() = "topTokens";
  picard_Picard_batchFeed_topTokens_2.is_optional_ref() = false;
  auto picard_Picard_batchFeed_topTokens_2_type = std::make_unique<List>(std::make_unique<List>(std::make_unique<Typedef>("picard.Token", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE))));
  picard_Picard_batchFeed_topTokens_2_type->writeAndGenType(*picard_Picard_batchFeed_topTokens_2.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(picard_Picard_batchFeed_topTokens_2));
  ::apache::thrift::metadata::ThriftField picard_Picard_batchFeed_mode_3;
  picard_Picard_batchFeed_mode_3.id_ref() = 3;
  picard_Picard_batchFeed_mode_3.name_ref() = "mode";
  picard_Picard_batchFeed_mode_3.is_optional_ref() = false;
  auto picard_Picard_batchFeed_mode_3_type = std::make_unique<Enum< ::cpp2::Mode>>("picard.Mode");
  picard_Picard_batchFeed_mode_3_type->writeAndGenType(*picard_Picard_batchFeed_mode_3.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(picard_Picard_batchFeed_mode_3));
  ::apache::thrift::metadata::ThriftField picard_Picard_batchFeed_fail_1;
  picard_Picard_batchFeed_fail_1.id_ref() = 1;
  picard_Picard_batchFeed_fail_1.name_ref() = "fail";
  picard_Picard_batchFeed_fail_1.is_optional_ref() = false;
  auto picard_Picard_batchFeed_fail_1_type = std::make_unique<Struct< ::cpp2::FeedException>>("picard.FeedException");
  picard_Picard_batchFeed_fail_1_type->writeAndGenType(*picard_Picard_batchFeed_fail_1.type_ref(), metadata);
  func.exceptions_ref()->push_back(std::move(picard_Picard_batchFeed_fail_1));
  ExceptionMetadata< ::cpp2::FeedException>::gen(metadata);
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}

void ServiceMetadata<::cpp2::PicardSvIf>::gen(ThriftMetadata& metadata, ThriftServiceContext& context) {
  (void) metadata;
  ::apache::thrift::metadata::ThriftService picard_Picard;
  picard_Picard.name_ref() = "picard.Picard";
  static const ThriftFunctionGenerator functions[] = {
    ServiceMetadata<::cpp2::PicardSvIf>::gen_registerSQLSchema,
    ServiceMetadata<::cpp2::PicardSvIf>::gen_registerTokenizer,
    ServiceMetadata<::cpp2::PicardSvIf>::gen_feed,
    ServiceMetadata<::cpp2::PicardSvIf>::gen_batchFeed,
  };
  for (auto& function_gen : functions) {
    function_gen(metadata, picard_Picard);
  }
  context.service_info_ref() = std::move(picard_Picard);
  ::apache::thrift::metadata::ThriftModuleContext module;
  module.name_ref() = "picard";
  context.module_ref() = std::move(module);
}
} // namespace md
} // namespace detail
} // namespace thrift
} // namespace apache
