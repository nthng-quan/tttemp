/**
 * Autogenerated by Thrift for picard.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include "Picard.h"

#include <thrift/lib/cpp2/gen/service_tcc.h>

namespace cpp2 {
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::string, ::cpp2::DBId*>, apache::thrift::FieldData<2, ::apache::thrift::type_class::structure, ::cpp2::SQLSchema*>> Picard_registerSQLSchema_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, ::cpp2::RegisterSQLSchemaException>> Picard_registerSQLSchema_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::string, ::std::string*>> Picard_registerTokenizer_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, ::cpp2::RegisterTokenizerException>> Picard_registerTokenizer_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::integral>, ::cpp2::InputIds*>, apache::thrift::FieldData<2, ::apache::thrift::type_class::integral, ::cpp2::Token*>, apache::thrift::FieldData<3, ::apache::thrift::type_class::enumeration, ::cpp2::Mode*>> Picard_feed_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::variant, ::cpp2::FeedResult*>, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, ::cpp2::FeedException>> Picard_feed_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::list<::apache::thrift::type_class::integral>>, ::std::vector<::cpp2::InputIds>*>, apache::thrift::FieldData<2, ::apache::thrift::type_class::list<::apache::thrift::type_class::list<::apache::thrift::type_class::integral>>, ::std::vector<::std::vector<::cpp2::Token>>*>, apache::thrift::FieldData<3, ::apache::thrift::type_class::enumeration, ::cpp2::Mode*>> Picard_batchFeed_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector<::cpp2::BatchFeedResult>*>, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, ::cpp2::FeedException>> Picard_batchFeed_presult;
template <typename ProtocolIn_, typename ProtocolOut_>
void PicardAsyncProcessor::setUpAndProcess_registerSQLSchema(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &PicardAsyncProcessor::process_registerSQLSchema<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void PicardAsyncProcessor::process_registerSQLSchema(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  Picard_registerSQLSchema_pargs args;
  auto uarg_dbId = std::make_unique<::cpp2::DBId>();
  args.get<0>().value = uarg_dbId.get();
  auto uarg_sqlSchema = std::make_unique<::cpp2::SQLSchema>();
  args.get<1>().value = uarg_sqlSchema.get();
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Picard.registerSQLSchema", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), std::move(serializedRequest).uncompress(), ctxStack.get());
  }
  catch (const std::exception& ex) {
    folly::exception_wrapper ew(std::current_exception(), ex);
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ew, std::move(req), ctx, eb, "registerSQLSchema");
    return;
  }
  if (!req->getShouldStartProcessing()) {
    apache::thrift::HandlerCallbackBase::releaseRequest(std::move(req), eb);
    return;
  }
  auto callback = std::make_unique<apache::thrift::HandlerCallback<void>>(std::move(req), std::move(ctxStack), return_registerSQLSchema<ProtocolIn_,ProtocolOut_>, throw_wrapped_registerSQLSchema<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  iface_->async_tm_registerSQLSchema(std::move(callback), std::move(uarg_dbId), std::move(uarg_sqlSchema));
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue PicardAsyncProcessor::return_registerSQLSchema(int32_t protoSeqId, apache::thrift::ContextStack* ctx) {
  ProtocolOut_ prot;
  Picard_registerSQLSchema_presult result;
  return serializeResponse("registerSQLSchema", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void PicardAsyncProcessor::throw_wrapped_registerSQLSchema(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  Picard_registerSQLSchema_presult result;
  if (ew.with_exception([&]( ::cpp2::RegisterSQLSchemaException& e) {
    ctx->userExceptionWrapped(true, ew);
    ::apache::thrift::util::appendExceptionToHeader(ew, *reqCtx);
    ::apache::thrift::util::appendErrorClassificationToHeader< ::cpp2::RegisterSQLSchemaException>(*reqCtx);                                                                
    result.get<0>().ref() = e;
    result.setIsSet(0, true);
  }
  )) {} else
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "registerSQLSchema");
    return;
  }
  ProtocolOut_ prot;
  auto queue = serializeResponse("registerSQLSchema", &prot, protoSeqId, ctx, result);
  queue.append(apache::thrift::transport::THeader::transform(queue.move(), reqCtx->getHeader()->getWriteTransforms()));
  return req->sendReply(queue.move());
}

template <typename ProtocolIn_, typename ProtocolOut_>
void PicardAsyncProcessor::setUpAndProcess_registerTokenizer(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &PicardAsyncProcessor::process_registerTokenizer<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void PicardAsyncProcessor::process_registerTokenizer(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  Picard_registerTokenizer_pargs args;
  auto uarg_jsonConfig = std::make_unique<::std::string>();
  args.get<0>().value = uarg_jsonConfig.get();
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Picard.registerTokenizer", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), std::move(serializedRequest).uncompress(), ctxStack.get());
  }
  catch (const std::exception& ex) {
    folly::exception_wrapper ew(std::current_exception(), ex);
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ew, std::move(req), ctx, eb, "registerTokenizer");
    return;
  }
  if (!req->getShouldStartProcessing()) {
    apache::thrift::HandlerCallbackBase::releaseRequest(std::move(req), eb);
    return;
  }
  auto callback = std::make_unique<apache::thrift::HandlerCallback<void>>(std::move(req), std::move(ctxStack), return_registerTokenizer<ProtocolIn_,ProtocolOut_>, throw_wrapped_registerTokenizer<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  iface_->async_tm_registerTokenizer(std::move(callback), std::move(uarg_jsonConfig));
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue PicardAsyncProcessor::return_registerTokenizer(int32_t protoSeqId, apache::thrift::ContextStack* ctx) {
  ProtocolOut_ prot;
  Picard_registerTokenizer_presult result;
  return serializeResponse("registerTokenizer", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void PicardAsyncProcessor::throw_wrapped_registerTokenizer(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  Picard_registerTokenizer_presult result;
  if (ew.with_exception([&]( ::cpp2::RegisterTokenizerException& e) {
    ctx->userExceptionWrapped(true, ew);
    ::apache::thrift::util::appendExceptionToHeader(ew, *reqCtx);
    ::apache::thrift::util::appendErrorClassificationToHeader< ::cpp2::RegisterTokenizerException>(*reqCtx);                                                                
    result.get<0>().ref() = e;
    result.setIsSet(0, true);
  }
  )) {} else
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "registerTokenizer");
    return;
  }
  ProtocolOut_ prot;
  auto queue = serializeResponse("registerTokenizer", &prot, protoSeqId, ctx, result);
  queue.append(apache::thrift::transport::THeader::transform(queue.move(), reqCtx->getHeader()->getWriteTransforms()));
  return req->sendReply(queue.move());
}

template <typename ProtocolIn_, typename ProtocolOut_>
void PicardAsyncProcessor::setUpAndProcess_feed(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &PicardAsyncProcessor::process_feed<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void PicardAsyncProcessor::process_feed(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  Picard_feed_pargs args;
  auto uarg_inputIds = std::make_unique<::cpp2::InputIds>();
  args.get<0>().value = uarg_inputIds.get();
  ::cpp2::Token uarg_token{0};
  args.get<1>().value = &uarg_token;
  ::cpp2::Mode uarg_mode{static_cast<::cpp2::Mode>(0)};
  args.get<2>().value = &uarg_mode;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Picard.feed", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), std::move(serializedRequest).uncompress(), ctxStack.get());
  }
  catch (const std::exception& ex) {
    folly::exception_wrapper ew(std::current_exception(), ex);
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ew, std::move(req), ctx, eb, "feed");
    return;
  }
  if (!req->getShouldStartProcessing()) {
    apache::thrift::HandlerCallbackBase::releaseRequest(std::move(req), eb);
    return;
  }
  auto callback = std::make_unique<apache::thrift::HandlerCallback<std::unique_ptr<::cpp2::FeedResult>>>(std::move(req), std::move(ctxStack), return_feed<ProtocolIn_,ProtocolOut_>, throw_wrapped_feed<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  iface_->async_tm_feed(std::move(callback), std::move(uarg_inputIds), args.get<1>().ref(), args.get<2>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue PicardAsyncProcessor::return_feed(int32_t protoSeqId, apache::thrift::ContextStack* ctx, ::cpp2::FeedResult const& _return) {
  ProtocolOut_ prot;
  Picard_feed_presult result;
  result.get<0>().value = const_cast<::cpp2::FeedResult*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("feed", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void PicardAsyncProcessor::throw_wrapped_feed(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  Picard_feed_presult result;
  if (ew.with_exception([&]( ::cpp2::FeedException& e) {
    ctx->userExceptionWrapped(true, ew);
    ::apache::thrift::util::appendExceptionToHeader(ew, *reqCtx);
    ::apache::thrift::util::appendErrorClassificationToHeader< ::cpp2::FeedException>(*reqCtx);                                                                
    result.get<1>().ref() = e;
    result.setIsSet(1, true);
  }
  )) {} else
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "feed");
    return;
  }
  ProtocolOut_ prot;
  auto queue = serializeResponse("feed", &prot, protoSeqId, ctx, result);
  queue.append(apache::thrift::transport::THeader::transform(queue.move(), reqCtx->getHeader()->getWriteTransforms()));
  return req->sendReply(queue.move());
}

template <typename ProtocolIn_, typename ProtocolOut_>
void PicardAsyncProcessor::setUpAndProcess_batchFeed(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(std::move(req), std::move(serializedRequest), ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, &PicardAsyncProcessor::process_batchFeed<ProtocolIn_, ProtocolOut_>, this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void PicardAsyncProcessor::process_batchFeed(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  Picard_batchFeed_pargs args;
  auto uarg_inputIds = std::make_unique<::std::vector<::cpp2::InputIds>>();
  args.get<0>().value = uarg_inputIds.get();
  auto uarg_topTokens = std::make_unique<::std::vector<::std::vector<::cpp2::Token>>>();
  args.get<1>().value = uarg_topTokens.get();
  ::cpp2::Mode uarg_mode{static_cast<::cpp2::Mode>(0)};
  args.get<2>().value = &uarg_mode;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Picard.batchFeed", ctx));
  try {
    deserializeRequest<ProtocolIn_>(args, ctx->getMethodName(), std::move(serializedRequest).uncompress(), ctxStack.get());
  }
  catch (const std::exception& ex) {
    folly::exception_wrapper ew(std::current_exception(), ex);
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ew, std::move(req), ctx, eb, "batchFeed");
    return;
  }
  if (!req->getShouldStartProcessing()) {
    apache::thrift::HandlerCallbackBase::releaseRequest(std::move(req), eb);
    return;
  }
  auto callback = std::make_unique<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::cpp2::BatchFeedResult>>>>(std::move(req), std::move(ctxStack), return_batchFeed<ProtocolIn_,ProtocolOut_>, throw_wrapped_batchFeed<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  iface_->async_tm_batchFeed(std::move(callback), std::move(uarg_inputIds), std::move(uarg_topTokens), args.get<2>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue PicardAsyncProcessor::return_batchFeed(int32_t protoSeqId, apache::thrift::ContextStack* ctx, ::std::vector<::cpp2::BatchFeedResult> const& _return) {
  ProtocolOut_ prot;
  Picard_batchFeed_presult result;
  result.get<0>().value = const_cast<::std::vector<::cpp2::BatchFeedResult>*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("batchFeed", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void PicardAsyncProcessor::throw_wrapped_batchFeed(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  Picard_batchFeed_presult result;
  if (ew.with_exception([&]( ::cpp2::FeedException& e) {
    ctx->userExceptionWrapped(true, ew);
    ::apache::thrift::util::appendExceptionToHeader(ew, *reqCtx);
    ::apache::thrift::util::appendErrorClassificationToHeader< ::cpp2::FeedException>(*reqCtx);                                                                
    result.get<1>().ref() = e;
    result.setIsSet(1, true);
  }
  )) {} else
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "batchFeed");
    return;
  }
  ProtocolOut_ prot;
  auto queue = serializeResponse("batchFeed", &prot, protoSeqId, ctx, result);
  queue.append(apache::thrift::transport::THeader::transform(queue.move(), reqCtx->getHeader()->getWriteTransforms()));
  return req->sendReply(queue.move());
}


} // cpp2
