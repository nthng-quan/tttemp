/**
 * Autogenerated by Thrift for picard.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "picard_types.h"
#include "picard_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "picard_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::cpp2::ColumnType>::size;
folly::Range<::cpp2::ColumnType const*> const TEnumTraits<::cpp2::ColumnType>::values = folly::range(TEnumDataStorage<::cpp2::ColumnType>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::cpp2::ColumnType>::names = folly::range(TEnumDataStorage<::cpp2::ColumnType>::names);

char const* TEnumTraits<::cpp2::ColumnType>::findName(type value) {
  using factory = ::cpp2::_ColumnType_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::cpp2::ColumnType>::findValue(char const* name, type* out) {
  using factory = ::cpp2::_ColumnType_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ColumnType_EnumMapFactory::ValuesToNamesMapType _ColumnType_VALUES_TO_NAMES = _ColumnType_EnumMapFactory::makeValuesToNamesMap();
const _ColumnType_EnumMapFactory::NamesToValuesMapType _ColumnType_NAMES_TO_VALUES = _ColumnType_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

} // cpp2

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::cpp2::Mode>::size;
folly::Range<::cpp2::Mode const*> const TEnumTraits<::cpp2::Mode>::values = folly::range(TEnumDataStorage<::cpp2::Mode>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::cpp2::Mode>::names = folly::range(TEnumDataStorage<::cpp2::Mode>::names);

char const* TEnumTraits<::cpp2::Mode>::findName(type value) {
  using factory = ::cpp2::_Mode_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::cpp2::Mode>::findValue(char const* name, type* out) {
  using factory = ::cpp2::_Mode_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _Mode_EnumMapFactory::ValuesToNamesMapType _Mode_VALUES_TO_NAMES = _Mode_EnumMapFactory::makeValuesToNamesMap();
const _Mode_EnumMapFactory::NamesToValuesMapType _Mode_NAMES_TO_VALUES = _Mode_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::SQLSchema>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::SQLSchema>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SQLSchema::SQLSchema() {}

THRIFT_IGNORE_ISSET_USE_WARNING_END

SQLSchema::~SQLSchema() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SQLSchema::SQLSchema(SQLSchema&& other) noexcept  :
    columnNames(std::move(other.columnNames)),
    columnTypes(std::move(other.columnTypes)),
    tableNames(std::move(other.tableNames)),
    columnToTable(std::move(other.columnToTable)),
    tableToColumns(std::move(other.tableToColumns)),
    foreignKeys(std::move(other.foreignKeys)),
    primaryKeys(std::move(other.primaryKeys)),
    __isset(other.__isset) {}

SQLSchema& SQLSchema::operator=(FOLLY_MAYBE_UNUSED SQLSchema&& other) noexcept {
    this->columnNames = std::move(other.columnNames);
    this->columnTypes = std::move(other.columnTypes);
    this->tableNames = std::move(other.tableNames);
    this->columnToTable = std::move(other.columnToTable);
    this->tableToColumns = std::move(other.tableToColumns);
    this->foreignKeys = std::move(other.foreignKeys);
    this->primaryKeys = std::move(other.primaryKeys);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
SQLSchema::SQLSchema(apache::thrift::FragileConstructor, ::std::map<::cpp2::ColumnId, ::std::string> columnNames__arg, ::std::map<::cpp2::ColumnId, ::cpp2::ColumnType> columnTypes__arg, ::std::map<::cpp2::TableId, ::std::string> tableNames__arg, ::std::map<::cpp2::ColumnId, ::cpp2::TableId> columnToTable__arg, ::std::map<::cpp2::TableId, ::std::vector<::cpp2::ColumnId>> tableToColumns__arg, ::std::map<::cpp2::ColumnId, ::cpp2::ColumnId> foreignKeys__arg, ::std::vector<::cpp2::ColumnId> primaryKeys__arg) :
    columnNames(std::move(columnNames__arg)),
    columnTypes(std::move(columnTypes__arg)),
    tableNames(std::move(tableNames__arg)),
    columnToTable(std::move(columnToTable__arg)),
    tableToColumns(std::move(tableToColumns__arg)),
    foreignKeys(std::move(foreignKeys__arg)),
    primaryKeys(std::move(primaryKeys__arg)) {
  __isset.columnNames = true;
  __isset.columnTypes = true;
  __isset.tableNames = true;
  __isset.columnToTable = true;
  __isset.tableToColumns = true;
  __isset.foreignKeys = true;
  __isset.primaryKeys = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void SQLSchema::__clear() {
  // clear all fields
  this->columnNames.clear();
  this->columnTypes.clear();
  this->tableNames.clear();
  this->columnToTable.clear();
  this->tableToColumns.clear();
  this->foreignKeys.clear();
  this->primaryKeys.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool SQLSchema::operator==(const SQLSchema& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.columnNames == rhs.columnNames)) {
    return false;
  }
  if (!(lhs.columnTypes == rhs.columnTypes)) {
    return false;
  }
  if (!(lhs.tableNames == rhs.tableNames)) {
    return false;
  }
  if (!(lhs.columnToTable == rhs.columnToTable)) {
    return false;
  }
  if (!(lhs.tableToColumns == rhs.tableToColumns)) {
    return false;
  }
  if (!(lhs.foreignKeys == rhs.foreignKeys)) {
    return false;
  }
  if (!(lhs.primaryKeys == rhs.primaryKeys)) {
    return false;
  }
  return true;
}

bool SQLSchema::operator<(const SQLSchema& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.columnNames == rhs.columnNames)) {
    return lhs.columnNames < rhs.columnNames;
  }
  if (!(lhs.columnTypes == rhs.columnTypes)) {
    return lhs.columnTypes < rhs.columnTypes;
  }
  if (!(lhs.tableNames == rhs.tableNames)) {
    return lhs.tableNames < rhs.tableNames;
  }
  if (!(lhs.columnToTable == rhs.columnToTable)) {
    return lhs.columnToTable < rhs.columnToTable;
  }
  if (!(lhs.tableToColumns == rhs.tableToColumns)) {
    return lhs.tableToColumns < rhs.tableToColumns;
  }
  if (!(lhs.foreignKeys == rhs.foreignKeys)) {
    return lhs.foreignKeys < rhs.foreignKeys;
  }
  if (!(lhs.primaryKeys == rhs.primaryKeys)) {
    return lhs.primaryKeys < rhs.primaryKeys;
  }
  return false;
}

const ::std::map<::cpp2::ColumnId, ::std::string>& SQLSchema::get_columnNames() const& {
  return columnNames;
}

::std::map<::cpp2::ColumnId, ::std::string> SQLSchema::get_columnNames() && {
  return std::move(columnNames);
}

const ::std::map<::cpp2::ColumnId, ::cpp2::ColumnType>& SQLSchema::get_columnTypes() const& {
  return columnTypes;
}

::std::map<::cpp2::ColumnId, ::cpp2::ColumnType> SQLSchema::get_columnTypes() && {
  return std::move(columnTypes);
}

const ::std::map<::cpp2::TableId, ::std::string>& SQLSchema::get_tableNames() const& {
  return tableNames;
}

::std::map<::cpp2::TableId, ::std::string> SQLSchema::get_tableNames() && {
  return std::move(tableNames);
}

const ::std::map<::cpp2::ColumnId, ::cpp2::TableId>& SQLSchema::get_columnToTable() const& {
  return columnToTable;
}

::std::map<::cpp2::ColumnId, ::cpp2::TableId> SQLSchema::get_columnToTable() && {
  return std::move(columnToTable);
}

const ::std::map<::cpp2::TableId, ::std::vector<::cpp2::ColumnId>>& SQLSchema::get_tableToColumns() const& {
  return tableToColumns;
}

::std::map<::cpp2::TableId, ::std::vector<::cpp2::ColumnId>> SQLSchema::get_tableToColumns() && {
  return std::move(tableToColumns);
}

const ::std::map<::cpp2::ColumnId, ::cpp2::ColumnId>& SQLSchema::get_foreignKeys() const& {
  return foreignKeys;
}

::std::map<::cpp2::ColumnId, ::cpp2::ColumnId> SQLSchema::get_foreignKeys() && {
  return std::move(foreignKeys);
}

const ::std::vector<::cpp2::ColumnId>& SQLSchema::get_primaryKeys() const& {
  return primaryKeys;
}

::std::vector<::cpp2::ColumnId> SQLSchema::get_primaryKeys() && {
  return std::move(primaryKeys);
}


void swap(SQLSchema& a, SQLSchema& b) {
  using ::std::swap;
  swap(a.columnNames_ref().value(), b.columnNames_ref().value());
  swap(a.columnTypes_ref().value(), b.columnTypes_ref().value());
  swap(a.tableNames_ref().value(), b.tableNames_ref().value());
  swap(a.columnToTable_ref().value(), b.columnToTable_ref().value());
  swap(a.tableToColumns_ref().value(), b.tableToColumns_ref().value());
  swap(a.foreignKeys_ref().value(), b.foreignKeys_ref().value());
  swap(a.primaryKeys_ref().value(), b.primaryKeys_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void SQLSchema::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SQLSchema::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SQLSchema::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SQLSchema::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SQLSchema::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SQLSchema::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SQLSchema::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SQLSchema::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::RegisterSQLSchemaException>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::RegisterSQLSchemaException>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RegisterSQLSchemaException::RegisterSQLSchemaException(RegisterSQLSchemaException&& other) noexcept  :
    dbId(std::move(other.dbId)),
    message(std::move(other.message)),
    __isset(other.__isset) {}

RegisterSQLSchemaException& RegisterSQLSchemaException::operator=(FOLLY_MAYBE_UNUSED RegisterSQLSchemaException&& other) noexcept {
    this->dbId = std::move(other.dbId);
    this->message = std::move(other.message);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RegisterSQLSchemaException::RegisterSQLSchemaException(apache::thrift::FragileConstructor, ::cpp2::DBId dbId__arg, ::std::string message__arg) :
    dbId(std::move(dbId__arg)),
    message(std::move(message__arg)) {
  __isset.dbId = true;
  __isset.message = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RegisterSQLSchemaException::__clear() {
  // clear all fields
  this->dbId = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->message = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RegisterSQLSchemaException::operator==(const RegisterSQLSchemaException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.dbId == rhs.dbId)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  return true;
}

bool RegisterSQLSchemaException::operator<(const RegisterSQLSchemaException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.dbId == rhs.dbId)) {
    return lhs.dbId < rhs.dbId;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  return false;
}


void swap(RegisterSQLSchemaException& a, RegisterSQLSchemaException& b) {
  using ::std::swap;
  swap(a.dbId_ref().value(), b.dbId_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RegisterSQLSchemaException::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RegisterSQLSchemaException::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RegisterSQLSchemaException::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RegisterSQLSchemaException::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RegisterSQLSchemaException::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RegisterSQLSchemaException::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RegisterSQLSchemaException::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RegisterSQLSchemaException::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::RegisterTokenizerException>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::RegisterTokenizerException>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RegisterTokenizerException::RegisterTokenizerException(RegisterTokenizerException&& other) noexcept  :
    message(std::move(other.message)),
    __isset(other.__isset) {}

RegisterTokenizerException& RegisterTokenizerException::operator=(FOLLY_MAYBE_UNUSED RegisterTokenizerException&& other) noexcept {
    this->message = std::move(other.message);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RegisterTokenizerException::RegisterTokenizerException(apache::thrift::FragileConstructor, ::std::string message__arg) :
    message(std::move(message__arg)) {
  __isset.message = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RegisterTokenizerException::__clear() {
  // clear all fields
  this->message = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RegisterTokenizerException::operator==(const RegisterTokenizerException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  return true;
}

bool RegisterTokenizerException::operator<(const RegisterTokenizerException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  return false;
}


void swap(RegisterTokenizerException& a, RegisterTokenizerException& b) {
  using ::std::swap;
  swap(a.message_ref().value(), b.message_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RegisterTokenizerException::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RegisterTokenizerException::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RegisterTokenizerException::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RegisterTokenizerException::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RegisterTokenizerException::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RegisterTokenizerException::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RegisterTokenizerException::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RegisterTokenizerException::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::TokenizerNotRegisteredException>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::TokenizerNotRegisteredException>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
TokenizerNotRegisteredException::TokenizerNotRegisteredException(TokenizerNotRegisteredException&& other) noexcept  :
    message(std::move(other.message)),
    __isset(other.__isset) {}

TokenizerNotRegisteredException& TokenizerNotRegisteredException::operator=(FOLLY_MAYBE_UNUSED TokenizerNotRegisteredException&& other) noexcept {
    this->message = std::move(other.message);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
TokenizerNotRegisteredException::TokenizerNotRegisteredException(apache::thrift::FragileConstructor, ::std::string message__arg) :
    message(std::move(message__arg)) {
  __isset.message = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void TokenizerNotRegisteredException::__clear() {
  // clear all fields
  this->message = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool TokenizerNotRegisteredException::operator==(const TokenizerNotRegisteredException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  return true;
}

bool TokenizerNotRegisteredException::operator<(const TokenizerNotRegisteredException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  return false;
}


void swap(TokenizerNotRegisteredException& a, TokenizerNotRegisteredException& b) {
  using ::std::swap;
  swap(a.message_ref().value(), b.message_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void TokenizerNotRegisteredException::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TokenizerNotRegisteredException::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TokenizerNotRegisteredException::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TokenizerNotRegisteredException::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TokenizerNotRegisteredException::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TokenizerNotRegisteredException::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TokenizerNotRegisteredException::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TokenizerNotRegisteredException::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::TokenizerPrefixException>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::TokenizerPrefixException>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
TokenizerPrefixException::TokenizerPrefixException(TokenizerPrefixException&& other) noexcept  :
    message(std::move(other.message)),
    __isset(other.__isset) {}

TokenizerPrefixException& TokenizerPrefixException::operator=(FOLLY_MAYBE_UNUSED TokenizerPrefixException&& other) noexcept {
    this->message = std::move(other.message);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
TokenizerPrefixException::TokenizerPrefixException(apache::thrift::FragileConstructor, ::std::string message__arg) :
    message(std::move(message__arg)) {
  __isset.message = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void TokenizerPrefixException::__clear() {
  // clear all fields
  this->message = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool TokenizerPrefixException::operator==(const TokenizerPrefixException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  return true;
}

bool TokenizerPrefixException::operator<(const TokenizerPrefixException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  return false;
}


void swap(TokenizerPrefixException& a, TokenizerPrefixException& b) {
  using ::std::swap;
  swap(a.message_ref().value(), b.message_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void TokenizerPrefixException::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TokenizerPrefixException::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TokenizerPrefixException::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TokenizerPrefixException::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TokenizerPrefixException::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TokenizerPrefixException::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TokenizerPrefixException::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TokenizerPrefixException::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::ModeException>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::ModeException>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ModeException::ModeException(ModeException&& other) noexcept  :
    message(std::move(other.message)),
    __isset(other.__isset) {}

ModeException& ModeException::operator=(FOLLY_MAYBE_UNUSED ModeException&& other) noexcept {
    this->message = std::move(other.message);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ModeException::ModeException(apache::thrift::FragileConstructor, ::std::string message__arg) :
    message(std::move(message__arg)) {
  __isset.message = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ModeException::__clear() {
  // clear all fields
  this->message = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ModeException::operator==(const ModeException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  return true;
}

bool ModeException::operator<(const ModeException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  return false;
}


void swap(ModeException& a, ModeException& b) {
  using ::std::swap;
  swap(a.message_ref().value(), b.message_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ModeException::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ModeException::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ModeException::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ModeException::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ModeException::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ModeException::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ModeException::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ModeException::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::FeedFatalException>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::FeedFatalException>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::cpp2::FeedFatalException::Type>::size;
folly::Range<::cpp2::FeedFatalException::Type const*> const TEnumTraits<::cpp2::FeedFatalException::Type>::values = folly::range(TEnumDataStorage<::cpp2::FeedFatalException::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::cpp2::FeedFatalException::Type>::names = folly::range(TEnumDataStorage<::cpp2::FeedFatalException::Type>::names);

char const* TEnumTraits<::cpp2::FeedFatalException::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::cpp2::FeedFatalException::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::cpp2::FeedFatalException::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::cpp2::FeedFatalException::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace cpp2 {

void FeedFatalException::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::tokenizerNotRegisteredException:
      destruct(value_.tokenizerNotRegisteredException);
      break;
    case Type::tokenizerPrefixException:
      destruct(value_.tokenizerPrefixException);
      break;
    case Type::modeException:
      destruct(value_.modeException);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool FeedFatalException::operator==(const FeedFatalException& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::tokenizerNotRegisteredException:
      return value_.tokenizerNotRegisteredException == rhs.value_.tokenizerNotRegisteredException;
    case Type::tokenizerPrefixException:
      return value_.tokenizerPrefixException == rhs.value_.tokenizerPrefixException;
    case Type::modeException:
      return value_.modeException == rhs.value_.modeException;
    default:
      return true;
  }
}

bool FeedFatalException::operator<(const FeedFatalException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::tokenizerNotRegisteredException:
      return lhs.value_.tokenizerNotRegisteredException < rhs.value_.tokenizerNotRegisteredException;
    case Type::tokenizerPrefixException:
      return lhs.value_.tokenizerPrefixException < rhs.value_.tokenizerPrefixException;
    case Type::modeException:
      return lhs.value_.modeException < rhs.value_.modeException;
    default:
      return false;
  }
}

void swap(FeedFatalException& a, FeedFatalException& b) {
  FeedFatalException temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void FeedFatalException::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t FeedFatalException::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t FeedFatalException::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t FeedFatalException::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void FeedFatalException::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t FeedFatalException::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t FeedFatalException::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t FeedFatalException::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        FeedFatalException,
        ::apache::thrift::type_class::structure,
        ::cpp2::TokenizerNotRegisteredException>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        FeedFatalException,
        ::apache::thrift::type_class::structure,
        ::cpp2::TokenizerPrefixException>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        FeedFatalException,
        ::apache::thrift::type_class::structure,
        ::cpp2::ModeException>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        FeedFatalException,
        ::apache::thrift::type_class::structure,
        ::cpp2::TokenizerNotRegisteredException>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        FeedFatalException,
        ::apache::thrift::type_class::structure,
        ::cpp2::TokenizerPrefixException>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        FeedFatalException,
        ::apache::thrift::type_class::structure,
        ::cpp2::ModeException>,
    "inconsistent use of nimble option");

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::FeedException>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::FeedException>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
FeedException::FeedException(FeedException&& other) noexcept  :
    feedFatalException(std::move(other.feedFatalException)),
    __isset(other.__isset) {}

FeedException& FeedException::operator=(FOLLY_MAYBE_UNUSED FeedException&& other) noexcept {
    this->feedFatalException = std::move(other.feedFatalException);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
FeedException::FeedException(apache::thrift::FragileConstructor, ::cpp2::FeedFatalException feedFatalException__arg) :
    feedFatalException(std::move(feedFatalException__arg)) {
  __isset.feedFatalException = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void FeedException::__clear() {
  // clear all fields
  this->feedFatalException.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool FeedException::operator==(const FeedException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.feedFatalException == rhs.feedFatalException)) {
    return false;
  }
  return true;
}

bool FeedException::operator<(const FeedException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.feedFatalException == rhs.feedFatalException)) {
    return lhs.feedFatalException < rhs.feedFatalException;
  }
  return false;
}

const ::cpp2::FeedFatalException& FeedException::get_feedFatalException() const& {
  return feedFatalException;
}

::cpp2::FeedFatalException FeedException::get_feedFatalException() && {
  return std::move(feedFatalException);
}


void swap(FeedException& a, FeedException& b) {
  using ::std::swap;
  swap(a.feedFatalException_ref().value(), b.feedFatalException_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void FeedException::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t FeedException::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t FeedException::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t FeedException::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void FeedException::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t FeedException::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t FeedException::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t FeedException::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        FeedException,
        ::apache::thrift::type_class::variant,
        ::cpp2::FeedFatalException>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        FeedException,
        ::apache::thrift::type_class::variant,
        ::cpp2::FeedFatalException>,
    "inconsistent use of nimble option");

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::FeedParseFailure>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::FeedParseFailure>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
FeedParseFailure::FeedParseFailure(FeedParseFailure&& other) noexcept  :
    input(std::move(other.input)),
    contexts(std::move(other.contexts)),
    description(std::move(other.description)),
    __isset(other.__isset) {}

FeedParseFailure& FeedParseFailure::operator=(FOLLY_MAYBE_UNUSED FeedParseFailure&& other) noexcept {
    this->input = std::move(other.input);
    this->contexts = std::move(other.contexts);
    this->description = std::move(other.description);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
FeedParseFailure::FeedParseFailure(apache::thrift::FragileConstructor, ::std::string input__arg, ::std::vector<::std::string> contexts__arg, ::std::string description__arg) :
    input(std::move(input__arg)),
    contexts(std::move(contexts__arg)),
    description(std::move(description__arg)) {
  __isset.input = true;
  __isset.contexts = true;
  __isset.description = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void FeedParseFailure::__clear() {
  // clear all fields
  this->input = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->contexts.clear();
  this->description = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool FeedParseFailure::operator==(const FeedParseFailure& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.input == rhs.input)) {
    return false;
  }
  if (!(lhs.contexts == rhs.contexts)) {
    return false;
  }
  if (!(lhs.description == rhs.description)) {
    return false;
  }
  return true;
}

bool FeedParseFailure::operator<(const FeedParseFailure& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.input == rhs.input)) {
    return lhs.input < rhs.input;
  }
  if (!(lhs.contexts == rhs.contexts)) {
    return lhs.contexts < rhs.contexts;
  }
  if (!(lhs.description == rhs.description)) {
    return lhs.description < rhs.description;
  }
  return false;
}

const ::std::vector<::std::string>& FeedParseFailure::get_contexts() const& {
  return contexts;
}

::std::vector<::std::string> FeedParseFailure::get_contexts() && {
  return std::move(contexts);
}


void swap(FeedParseFailure& a, FeedParseFailure& b) {
  using ::std::swap;
  swap(a.input_ref().value(), b.input_ref().value());
  swap(a.contexts_ref().value(), b.contexts_ref().value());
  swap(a.description_ref().value(), b.description_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void FeedParseFailure::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t FeedParseFailure::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t FeedParseFailure::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t FeedParseFailure::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void FeedParseFailure::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t FeedParseFailure::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t FeedParseFailure::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t FeedParseFailure::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::FeedTimeoutFailure>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::FeedTimeoutFailure>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
FeedTimeoutFailure::FeedTimeoutFailure(FeedTimeoutFailure&& other) noexcept  :
    message(std::move(other.message)),
    __isset(other.__isset) {}

FeedTimeoutFailure& FeedTimeoutFailure::operator=(FOLLY_MAYBE_UNUSED FeedTimeoutFailure&& other) noexcept {
    this->message = std::move(other.message);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
FeedTimeoutFailure::FeedTimeoutFailure(apache::thrift::FragileConstructor, ::std::string message__arg) :
    message(std::move(message__arg)) {
  __isset.message = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void FeedTimeoutFailure::__clear() {
  // clear all fields
  this->message = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool FeedTimeoutFailure::operator==(const FeedTimeoutFailure& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  return true;
}

bool FeedTimeoutFailure::operator<(const FeedTimeoutFailure& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  return false;
}


void swap(FeedTimeoutFailure& a, FeedTimeoutFailure& b) {
  using ::std::swap;
  swap(a.message_ref().value(), b.message_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void FeedTimeoutFailure::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t FeedTimeoutFailure::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t FeedTimeoutFailure::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t FeedTimeoutFailure::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void FeedTimeoutFailure::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t FeedTimeoutFailure::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t FeedTimeoutFailure::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t FeedTimeoutFailure::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::FeedPartialSuccess>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::FeedPartialSuccess>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
FeedPartialSuccess::FeedPartialSuccess(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void FeedPartialSuccess::__clear() {
  // clear all fields
}

bool FeedPartialSuccess::operator==(const FeedPartialSuccess& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool FeedPartialSuccess::operator<(const FeedPartialSuccess& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(FeedPartialSuccess& a, FeedPartialSuccess& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void FeedPartialSuccess::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t FeedPartialSuccess::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t FeedPartialSuccess::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t FeedPartialSuccess::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void FeedPartialSuccess::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t FeedPartialSuccess::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t FeedPartialSuccess::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t FeedPartialSuccess::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::FeedCompleteSuccess>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::FeedCompleteSuccess>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
FeedCompleteSuccess::FeedCompleteSuccess(FeedCompleteSuccess&& other) noexcept  :
    leftover(std::move(other.leftover)),
    __isset(other.__isset) {}

FeedCompleteSuccess& FeedCompleteSuccess::operator=(FOLLY_MAYBE_UNUSED FeedCompleteSuccess&& other) noexcept {
    this->leftover = std::move(other.leftover);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
FeedCompleteSuccess::FeedCompleteSuccess(apache::thrift::FragileConstructor, ::std::string leftover__arg) :
    leftover(std::move(leftover__arg)) {
  __isset.leftover = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void FeedCompleteSuccess::__clear() {
  // clear all fields
  this->leftover = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool FeedCompleteSuccess::operator==(const FeedCompleteSuccess& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.leftover == rhs.leftover)) {
    return false;
  }
  return true;
}

bool FeedCompleteSuccess::operator<(const FeedCompleteSuccess& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.leftover == rhs.leftover)) {
    return lhs.leftover < rhs.leftover;
  }
  return false;
}


void swap(FeedCompleteSuccess& a, FeedCompleteSuccess& b) {
  using ::std::swap;
  swap(a.leftover_ref().value(), b.leftover_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void FeedCompleteSuccess::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t FeedCompleteSuccess::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t FeedCompleteSuccess::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t FeedCompleteSuccess::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void FeedCompleteSuccess::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t FeedCompleteSuccess::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t FeedCompleteSuccess::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t FeedCompleteSuccess::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::FeedResult>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::FeedResult>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::cpp2::FeedResult::Type>::size;
folly::Range<::cpp2::FeedResult::Type const*> const TEnumTraits<::cpp2::FeedResult::Type>::values = folly::range(TEnumDataStorage<::cpp2::FeedResult::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::cpp2::FeedResult::Type>::names = folly::range(TEnumDataStorage<::cpp2::FeedResult::Type>::names);

char const* TEnumTraits<::cpp2::FeedResult::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::cpp2::FeedResult::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::cpp2::FeedResult::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::cpp2::FeedResult::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace cpp2 {

void FeedResult::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::feedParseFailure:
      destruct(value_.feedParseFailure);
      break;
    case Type::feedTimeoutFailure:
      destruct(value_.feedTimeoutFailure);
      break;
    case Type::feedPartialSuccess:
      destruct(value_.feedPartialSuccess);
      break;
    case Type::feedCompleteSuccess:
      destruct(value_.feedCompleteSuccess);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool FeedResult::operator==(const FeedResult& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::feedParseFailure:
      return value_.feedParseFailure == rhs.value_.feedParseFailure;
    case Type::feedTimeoutFailure:
      return value_.feedTimeoutFailure == rhs.value_.feedTimeoutFailure;
    case Type::feedPartialSuccess:
      return value_.feedPartialSuccess == rhs.value_.feedPartialSuccess;
    case Type::feedCompleteSuccess:
      return value_.feedCompleteSuccess == rhs.value_.feedCompleteSuccess;
    default:
      return true;
  }
}

bool FeedResult::operator<(const FeedResult& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::feedParseFailure:
      return lhs.value_.feedParseFailure < rhs.value_.feedParseFailure;
    case Type::feedTimeoutFailure:
      return lhs.value_.feedTimeoutFailure < rhs.value_.feedTimeoutFailure;
    case Type::feedPartialSuccess:
      return lhs.value_.feedPartialSuccess < rhs.value_.feedPartialSuccess;
    case Type::feedCompleteSuccess:
      return lhs.value_.feedCompleteSuccess < rhs.value_.feedCompleteSuccess;
    default:
      return false;
  }
}

void swap(FeedResult& a, FeedResult& b) {
  FeedResult temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void FeedResult::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t FeedResult::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t FeedResult::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t FeedResult::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void FeedResult::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t FeedResult::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t FeedResult::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t FeedResult::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        FeedResult,
        ::apache::thrift::type_class::structure,
        ::cpp2::FeedParseFailure>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        FeedResult,
        ::apache::thrift::type_class::structure,
        ::cpp2::FeedTimeoutFailure>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        FeedResult,
        ::apache::thrift::type_class::structure,
        ::cpp2::FeedPartialSuccess>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        FeedResult,
        ::apache::thrift::type_class::structure,
        ::cpp2::FeedCompleteSuccess>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        FeedResult,
        ::apache::thrift::type_class::structure,
        ::cpp2::FeedParseFailure>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        FeedResult,
        ::apache::thrift::type_class::structure,
        ::cpp2::FeedTimeoutFailure>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        FeedResult,
        ::apache::thrift::type_class::structure,
        ::cpp2::FeedPartialSuccess>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        FeedResult,
        ::apache::thrift::type_class::structure,
        ::cpp2::FeedCompleteSuccess>,
    "inconsistent use of nimble option");

} // cpp2

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::BatchFeedResult>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::BatchFeedResult>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
BatchFeedResult::BatchFeedResult(BatchFeedResult&& other) noexcept  :
    batchId(std::move(other.batchId)),
    topToken(std::move(other.topToken)),
    feedResult(std::move(other.feedResult)),
    __isset(other.__isset) {}

BatchFeedResult& BatchFeedResult::operator=(FOLLY_MAYBE_UNUSED BatchFeedResult&& other) noexcept {
    this->batchId = std::move(other.batchId);
    this->topToken = std::move(other.topToken);
    this->feedResult = std::move(other.feedResult);
    __isset = other.__isset;
    return *this;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END


THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
BatchFeedResult::BatchFeedResult(apache::thrift::FragileConstructor, ::cpp2::BatchId batchId__arg, ::cpp2::Token topToken__arg, ::cpp2::FeedResult feedResult__arg) :
    batchId(std::move(batchId__arg)),
    topToken(std::move(topToken__arg)),
    feedResult(std::move(feedResult__arg)) {
  __isset.batchId = true;
  __isset.topToken = true;
  __isset.feedResult = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void BatchFeedResult::__clear() {
  // clear all fields
  this->batchId = 0;
  this->topToken = 0;
  this->feedResult.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool BatchFeedResult::operator==(const BatchFeedResult& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.batchId == rhs.batchId)) {
    return false;
  }
  if (!(lhs.topToken == rhs.topToken)) {
    return false;
  }
  if (!(lhs.feedResult == rhs.feedResult)) {
    return false;
  }
  return true;
}

bool BatchFeedResult::operator<(const BatchFeedResult& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.batchId == rhs.batchId)) {
    return lhs.batchId < rhs.batchId;
  }
  if (!(lhs.topToken == rhs.topToken)) {
    return lhs.topToken < rhs.topToken;
  }
  if (!(lhs.feedResult == rhs.feedResult)) {
    return lhs.feedResult < rhs.feedResult;
  }
  return false;
}

const ::cpp2::FeedResult& BatchFeedResult::get_feedResult() const& {
  return feedResult;
}

::cpp2::FeedResult BatchFeedResult::get_feedResult() && {
  return std::move(feedResult);
}


void swap(BatchFeedResult& a, BatchFeedResult& b) {
  using ::std::swap;
  swap(a.batchId_ref().value(), b.batchId_ref().value());
  swap(a.topToken_ref().value(), b.topToken_ref().value());
  swap(a.feedResult_ref().value(), b.feedResult_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void BatchFeedResult::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t BatchFeedResult::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t BatchFeedResult::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t BatchFeedResult::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void BatchFeedResult::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t BatchFeedResult::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t BatchFeedResult::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t BatchFeedResult::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        BatchFeedResult,
        ::apache::thrift::type_class::variant,
        ::cpp2::FeedResult>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        BatchFeedResult,
        ::apache::thrift::type_class::variant,
        ::cpp2::FeedResult>,
    "inconsistent use of nimble option");

} // cpp2
