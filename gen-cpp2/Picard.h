/**
 * Autogenerated by Thrift for picard.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/service_h.h>

#include "PicardAsyncClient.h"
#include "picard_types.h"

namespace folly {
  class IOBuf;
  class IOBufQueue;
}
namespace apache { namespace thrift {
  class Cpp2RequestContext;
  class BinaryProtocolReader;
  class CompactProtocolReader;
  namespace transport { class THeader; }
}}

namespace cpp2 {

class PicardSvAsyncIf {
 public:
  virtual ~PicardSvAsyncIf() {}
  virtual void async_tm_registerSQLSchema(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback, std::unique_ptr<::cpp2::DBId> p_dbId, std::unique_ptr<::cpp2::SQLSchema> p_sqlSchema) = 0;
  virtual folly::Future<folly::Unit> future_registerSQLSchema(std::unique_ptr<::cpp2::DBId> p_dbId, std::unique_ptr<::cpp2::SQLSchema> p_sqlSchema) = 0;
  virtual folly::SemiFuture<folly::Unit> semifuture_registerSQLSchema(std::unique_ptr<::cpp2::DBId> p_dbId, std::unique_ptr<::cpp2::SQLSchema> p_sqlSchema) = 0;
  virtual void async_tm_registerTokenizer(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback, std::unique_ptr<::std::string> p_jsonConfig) = 0;
  virtual folly::Future<folly::Unit> future_registerTokenizer(std::unique_ptr<::std::string> p_jsonConfig) = 0;
  virtual folly::SemiFuture<folly::Unit> semifuture_registerTokenizer(std::unique_ptr<::std::string> p_jsonConfig) = 0;
  virtual void async_tm_feed(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::cpp2::FeedResult>>> callback, std::unique_ptr<::cpp2::InputIds> p_inputIds, ::cpp2::Token p_token, ::cpp2::Mode p_mode) = 0;
  virtual folly::Future<std::unique_ptr<::cpp2::FeedResult>> future_feed(std::unique_ptr<::cpp2::InputIds> p_inputIds, ::cpp2::Token p_token, ::cpp2::Mode p_mode) = 0;
  virtual folly::SemiFuture<std::unique_ptr<::cpp2::FeedResult>> semifuture_feed(std::unique_ptr<::cpp2::InputIds> p_inputIds, ::cpp2::Token p_token, ::cpp2::Mode p_mode) = 0;
  virtual void async_tm_batchFeed(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::cpp2::BatchFeedResult>>>> callback, std::unique_ptr<::std::vector<::cpp2::InputIds>> p_inputIds, std::unique_ptr<::std::vector<::std::vector<::cpp2::Token>>> p_topTokens, ::cpp2::Mode p_mode) = 0;
  virtual folly::Future<std::unique_ptr<::std::vector<::cpp2::BatchFeedResult>>> future_batchFeed(std::unique_ptr<::std::vector<::cpp2::InputIds>> p_inputIds, std::unique_ptr<::std::vector<::std::vector<::cpp2::Token>>> p_topTokens, ::cpp2::Mode p_mode) = 0;
  virtual folly::SemiFuture<std::unique_ptr<::std::vector<::cpp2::BatchFeedResult>>> semifuture_batchFeed(std::unique_ptr<::std::vector<::cpp2::InputIds>> p_inputIds, std::unique_ptr<::std::vector<::std::vector<::cpp2::Token>>> p_topTokens, ::cpp2::Mode p_mode) = 0;
};

class PicardAsyncProcessor;

class PicardSvIf : public PicardSvAsyncIf, public apache::thrift::ServerInterface {
 public:
  typedef PicardAsyncProcessor ProcessorType;
  std::unique_ptr<apache::thrift::AsyncProcessor> getProcessor() override;


  virtual void registerSQLSchema(std::unique_ptr<::cpp2::DBId> /*dbId*/, std::unique_ptr<::cpp2::SQLSchema> /*sqlSchema*/);
  folly::Future<folly::Unit> future_registerSQLSchema(std::unique_ptr<::cpp2::DBId> p_dbId, std::unique_ptr<::cpp2::SQLSchema> p_sqlSchema) override;
  folly::SemiFuture<folly::Unit> semifuture_registerSQLSchema(std::unique_ptr<::cpp2::DBId> p_dbId, std::unique_ptr<::cpp2::SQLSchema> p_sqlSchema) override;
  void async_tm_registerSQLSchema(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback, std::unique_ptr<::cpp2::DBId> p_dbId, std::unique_ptr<::cpp2::SQLSchema> p_sqlSchema) override;
  virtual void registerTokenizer(std::unique_ptr<::std::string> /*jsonConfig*/);
  folly::Future<folly::Unit> future_registerTokenizer(std::unique_ptr<::std::string> p_jsonConfig) override;
  folly::SemiFuture<folly::Unit> semifuture_registerTokenizer(std::unique_ptr<::std::string> p_jsonConfig) override;
  void async_tm_registerTokenizer(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback, std::unique_ptr<::std::string> p_jsonConfig) override;
  virtual void feed(::cpp2::FeedResult& /*_return*/, std::unique_ptr<::cpp2::InputIds> /*inputIds*/, ::cpp2::Token /*token*/, ::cpp2::Mode /*mode*/);
  folly::Future<std::unique_ptr<::cpp2::FeedResult>> future_feed(std::unique_ptr<::cpp2::InputIds> p_inputIds, ::cpp2::Token p_token, ::cpp2::Mode p_mode) override;
  folly::SemiFuture<std::unique_ptr<::cpp2::FeedResult>> semifuture_feed(std::unique_ptr<::cpp2::InputIds> p_inputIds, ::cpp2::Token p_token, ::cpp2::Mode p_mode) override;
  void async_tm_feed(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::cpp2::FeedResult>>> callback, std::unique_ptr<::cpp2::InputIds> p_inputIds, ::cpp2::Token p_token, ::cpp2::Mode p_mode) override;
  virtual void batchFeed(::std::vector<::cpp2::BatchFeedResult>& /*_return*/, std::unique_ptr<::std::vector<::cpp2::InputIds>> /*inputIds*/, std::unique_ptr<::std::vector<::std::vector<::cpp2::Token>>> /*topTokens*/, ::cpp2::Mode /*mode*/);
  folly::Future<std::unique_ptr<::std::vector<::cpp2::BatchFeedResult>>> future_batchFeed(std::unique_ptr<::std::vector<::cpp2::InputIds>> p_inputIds, std::unique_ptr<::std::vector<::std::vector<::cpp2::Token>>> p_topTokens, ::cpp2::Mode p_mode) override;
  folly::SemiFuture<std::unique_ptr<::std::vector<::cpp2::BatchFeedResult>>> semifuture_batchFeed(std::unique_ptr<::std::vector<::cpp2::InputIds>> p_inputIds, std::unique_ptr<::std::vector<::std::vector<::cpp2::Token>>> p_topTokens, ::cpp2::Mode p_mode) override;
  void async_tm_batchFeed(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::cpp2::BatchFeedResult>>>> callback, std::unique_ptr<::std::vector<::cpp2::InputIds>> p_inputIds, std::unique_ptr<::std::vector<::std::vector<::cpp2::Token>>> p_topTokens, ::cpp2::Mode p_mode) override;
 private:
  std::atomic<apache::thrift::detail::si::InvocationType> __fbthrift_invocation_registerSQLSchema{apache::thrift::detail::si::InvocationType::AsyncTm};
  std::atomic<apache::thrift::detail::si::InvocationType> __fbthrift_invocation_registerTokenizer{apache::thrift::detail::si::InvocationType::AsyncTm};
  std::atomic<apache::thrift::detail::si::InvocationType> __fbthrift_invocation_feed{apache::thrift::detail::si::InvocationType::AsyncTm};
  std::atomic<apache::thrift::detail::si::InvocationType> __fbthrift_invocation_batchFeed{apache::thrift::detail::si::InvocationType::AsyncTm};
};

class PicardSvNull : public PicardSvIf {
 public:
  void registerSQLSchema(std::unique_ptr<::cpp2::DBId> /*dbId*/, std::unique_ptr<::cpp2::SQLSchema> /*sqlSchema*/) override;
  void registerTokenizer(std::unique_ptr<::std::string> /*jsonConfig*/) override;
  void feed(::cpp2::FeedResult& /*_return*/, std::unique_ptr<::cpp2::InputIds> /*inputIds*/, ::cpp2::Token /*token*/, ::cpp2::Mode /*mode*/) override;
  void batchFeed(::std::vector<::cpp2::BatchFeedResult>& /*_return*/, std::unique_ptr<::std::vector<::cpp2::InputIds>> /*inputIds*/, std::unique_ptr<::std::vector<::std::vector<::cpp2::Token>>> /*topTokens*/, ::cpp2::Mode /*mode*/) override;
};

class PicardAsyncProcessor : public ::apache::thrift::GeneratedAsyncProcessor {
 public:
  const char* getServiceName() override;
  void getServiceMetadata(apache::thrift::metadata::ThriftServiceMetadataResponse& response) override;
  using BaseAsyncProcessor = void;
 protected:
  PicardSvIf* iface_;
 public:
  void processSerializedCompressedRequest(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::protocol::PROTOCOL_TYPES protType, apache::thrift::Cpp2RequestContext* context, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) override;
 protected:
  std::shared_ptr<folly::RequestContext> getBaseContextForRequest() override;
 public:
  using ProcessFunc = GeneratedAsyncProcessor::ProcessFunc<PicardAsyncProcessor>;
  using ProcessMap = GeneratedAsyncProcessor::ProcessMap<ProcessFunc>;
  static const PicardAsyncProcessor::ProcessMap& getBinaryProtocolProcessMap();
  static const PicardAsyncProcessor::ProcessMap& getCompactProtocolProcessMap();
 private:
  static const PicardAsyncProcessor::ProcessMap binaryProcessMap_;
  static const PicardAsyncProcessor::ProcessMap compactProcessMap_;
 private:
  template <typename ProtocolIn_, typename ProtocolOut_>
  void setUpAndProcess_registerSQLSchema(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void process_registerSQLSchema(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <class ProtocolIn_, class ProtocolOut_>
  static folly::IOBufQueue return_registerSQLSchema(int32_t protoSeqId, apache::thrift::ContextStack* ctx);
  template <class ProtocolIn_, class ProtocolOut_>
  static void throw_wrapped_registerSQLSchema(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void setUpAndProcess_registerTokenizer(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void process_registerTokenizer(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <class ProtocolIn_, class ProtocolOut_>
  static folly::IOBufQueue return_registerTokenizer(int32_t protoSeqId, apache::thrift::ContextStack* ctx);
  template <class ProtocolIn_, class ProtocolOut_>
  static void throw_wrapped_registerTokenizer(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void setUpAndProcess_feed(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void process_feed(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <class ProtocolIn_, class ProtocolOut_>
  static folly::IOBufQueue return_feed(int32_t protoSeqId, apache::thrift::ContextStack* ctx, ::cpp2::FeedResult const& _return);
  template <class ProtocolIn_, class ProtocolOut_>
  static void throw_wrapped_feed(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void setUpAndProcess_batchFeed(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <typename ProtocolIn_, typename ProtocolOut_>
  void process_batchFeed(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm);
  template <class ProtocolIn_, class ProtocolOut_>
  static folly::IOBufQueue return_batchFeed(int32_t protoSeqId, apache::thrift::ContextStack* ctx, ::std::vector<::cpp2::BatchFeedResult> const& _return);
  template <class ProtocolIn_, class ProtocolOut_>
  static void throw_wrapped_batchFeed(apache::thrift::ResponseChannelRequest::UniquePtr req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx);
 public:
  PicardAsyncProcessor(PicardSvIf* iface) :
      iface_(iface) {}

  virtual ~PicardAsyncProcessor() {}
};

} // cpp2
