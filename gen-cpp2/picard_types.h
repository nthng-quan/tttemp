/**
 * Autogenerated by Thrift for picard.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>



namespace apache {
namespace thrift {
namespace tag {
struct columnNames;
struct columnTypes;
struct tableNames;
struct columnToTable;
struct tableToColumns;
struct foreignKeys;
struct primaryKeys;
struct dbId;
struct message;
struct message;
struct message;
struct message;
struct message;
struct tokenizerNotRegisteredException;
struct tokenizerPrefixException;
struct modeException;
struct feedFatalException;
struct input;
struct contexts;
struct description;
struct message;
struct leftover;
struct feedParseFailure;
struct feedTimeoutFailure;
struct feedPartialSuccess;
struct feedCompleteSuccess;
struct batchId;
struct topToken;
struct feedResult;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_columnNames
#define APACHE_THRIFT_ACCESSOR_columnNames
APACHE_THRIFT_DEFINE_ACCESSOR(columnNames);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_columnTypes
#define APACHE_THRIFT_ACCESSOR_columnTypes
APACHE_THRIFT_DEFINE_ACCESSOR(columnTypes);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tableNames
#define APACHE_THRIFT_ACCESSOR_tableNames
APACHE_THRIFT_DEFINE_ACCESSOR(tableNames);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_columnToTable
#define APACHE_THRIFT_ACCESSOR_columnToTable
APACHE_THRIFT_DEFINE_ACCESSOR(columnToTable);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tableToColumns
#define APACHE_THRIFT_ACCESSOR_tableToColumns
APACHE_THRIFT_DEFINE_ACCESSOR(tableToColumns);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_foreignKeys
#define APACHE_THRIFT_ACCESSOR_foreignKeys
APACHE_THRIFT_DEFINE_ACCESSOR(foreignKeys);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_primaryKeys
#define APACHE_THRIFT_ACCESSOR_primaryKeys
APACHE_THRIFT_DEFINE_ACCESSOR(primaryKeys);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_dbId
#define APACHE_THRIFT_ACCESSOR_dbId
APACHE_THRIFT_DEFINE_ACCESSOR(dbId);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_message
#define APACHE_THRIFT_ACCESSOR_message
APACHE_THRIFT_DEFINE_ACCESSOR(message);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_message
#define APACHE_THRIFT_ACCESSOR_message
APACHE_THRIFT_DEFINE_ACCESSOR(message);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_message
#define APACHE_THRIFT_ACCESSOR_message
APACHE_THRIFT_DEFINE_ACCESSOR(message);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_message
#define APACHE_THRIFT_ACCESSOR_message
APACHE_THRIFT_DEFINE_ACCESSOR(message);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_message
#define APACHE_THRIFT_ACCESSOR_message
APACHE_THRIFT_DEFINE_ACCESSOR(message);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tokenizerNotRegisteredException
#define APACHE_THRIFT_ACCESSOR_tokenizerNotRegisteredException
APACHE_THRIFT_DEFINE_ACCESSOR(tokenizerNotRegisteredException);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_tokenizerPrefixException
#define APACHE_THRIFT_ACCESSOR_tokenizerPrefixException
APACHE_THRIFT_DEFINE_ACCESSOR(tokenizerPrefixException);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_modeException
#define APACHE_THRIFT_ACCESSOR_modeException
APACHE_THRIFT_DEFINE_ACCESSOR(modeException);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_feedFatalException
#define APACHE_THRIFT_ACCESSOR_feedFatalException
APACHE_THRIFT_DEFINE_ACCESSOR(feedFatalException);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_input
#define APACHE_THRIFT_ACCESSOR_input
APACHE_THRIFT_DEFINE_ACCESSOR(input);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_contexts
#define APACHE_THRIFT_ACCESSOR_contexts
APACHE_THRIFT_DEFINE_ACCESSOR(contexts);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_description
#define APACHE_THRIFT_ACCESSOR_description
APACHE_THRIFT_DEFINE_ACCESSOR(description);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_message
#define APACHE_THRIFT_ACCESSOR_message
APACHE_THRIFT_DEFINE_ACCESSOR(message);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_leftover
#define APACHE_THRIFT_ACCESSOR_leftover
APACHE_THRIFT_DEFINE_ACCESSOR(leftover);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_feedParseFailure
#define APACHE_THRIFT_ACCESSOR_feedParseFailure
APACHE_THRIFT_DEFINE_ACCESSOR(feedParseFailure);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_feedTimeoutFailure
#define APACHE_THRIFT_ACCESSOR_feedTimeoutFailure
APACHE_THRIFT_DEFINE_ACCESSOR(feedTimeoutFailure);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_feedPartialSuccess
#define APACHE_THRIFT_ACCESSOR_feedPartialSuccess
APACHE_THRIFT_DEFINE_ACCESSOR(feedPartialSuccess);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_feedCompleteSuccess
#define APACHE_THRIFT_ACCESSOR_feedCompleteSuccess
APACHE_THRIFT_DEFINE_ACCESSOR(feedCompleteSuccess);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_batchId
#define APACHE_THRIFT_ACCESSOR_batchId
APACHE_THRIFT_DEFINE_ACCESSOR(batchId);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_topToken
#define APACHE_THRIFT_ACCESSOR_topToken
APACHE_THRIFT_DEFINE_ACCESSOR(topToken);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_feedResult
#define APACHE_THRIFT_ACCESSOR_feedResult
APACHE_THRIFT_DEFINE_ACCESSOR(feedResult);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace cpp2 {

enum class ColumnType {
  BOOLEAN = 1,
  TEXT = 2,
  NUMBER = 3,
  TIME = 4,
  OTHERS = 5,
};




enum class Mode {
  LEXING = 1,
  PARSING_WITHOUT_GUARDS = 2,
  PARSING_WITH_GUARDS = 3,
  PARSING_WITH_GUARDS_AND_TYPE_CHECKING = 4,
};




} // cpp2

namespace std {
template<> struct hash<::cpp2::ColumnType> :
  ::apache::thrift::detail::enum_hash<::cpp2::ColumnType> {};
template<> struct hash<::cpp2::Mode> :
  ::apache::thrift::detail::enum_hash<::cpp2::Mode> {};
} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::cpp2::ColumnType>;

template <> struct TEnumTraits<::cpp2::ColumnType> {
  using type = ::cpp2::ColumnType;

  static constexpr std::size_t const size = 5;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::BOOLEAN; }
  static constexpr type max() { return type::OTHERS; }
};


template <> struct TEnumDataStorage<::cpp2::Mode>;

template <> struct TEnumTraits<::cpp2::Mode> {
  using type = ::cpp2::Mode;

  static constexpr std::size_t const size = 4;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::LEXING; }
  static constexpr type max() { return type::PARSING_WITH_GUARDS_AND_TYPE_CHECKING; }
};


}} // apache::thrift

namespace cpp2 {

using _ColumnType_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<ColumnType>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _ColumnType_EnumMapFactory::ValuesToNamesMapType _ColumnType_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _ColumnType_EnumMapFactory::NamesToValuesMapType _ColumnType_NAMES_TO_VALUES;

using _Mode_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<Mode>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _Mode_EnumMapFactory::ValuesToNamesMapType _Mode_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _Mode_EnumMapFactory::NamesToValuesMapType _Mode_NAMES_TO_VALUES;

} // cpp2

// END declare_enums
// BEGIN forward_declare
namespace cpp2 {
class SQLSchema;
class RegisterSQLSchemaException;
class RegisterTokenizerException;
class TokenizerNotRegisteredException;
class TokenizerPrefixException;
class ModeException;
class FeedFatalException;
class FeedException;
class FeedParseFailure;
class FeedTimeoutFailure;
class FeedPartialSuccess;
class FeedCompleteSuccess;
class FeedResult;
class BatchFeedResult;
} // cpp2
// END forward_declare
// BEGIN typedefs
namespace cpp2 {
typedef ::std::string ColumnId;
typedef ::std::string TableId;
typedef ::std::string DBId;
typedef ::std::int64_t Token;
typedef ::std::vector<::cpp2::Token> InputIds;
typedef ::std::int64_t BatchId;

} // cpp2
// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
namespace cpp2 {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class SQLSchema final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = SQLSchema;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  SQLSchema();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  SQLSchema(apache::thrift::FragileConstructor, ::std::map<::cpp2::ColumnId, ::std::string> columnNames__arg, ::std::map<::cpp2::ColumnId, ::cpp2::ColumnType> columnTypes__arg, ::std::map<::cpp2::TableId, ::std::string> tableNames__arg, ::std::map<::cpp2::ColumnId, ::cpp2::TableId> columnToTable__arg, ::std::map<::cpp2::TableId, ::std::vector<::cpp2::ColumnId>> tableToColumns__arg, ::std::map<::cpp2::ColumnId, ::cpp2::ColumnId> foreignKeys__arg, ::std::vector<::cpp2::ColumnId> primaryKeys__arg);

  SQLSchema(SQLSchema&&) noexcept;

  SQLSchema(const SQLSchema&) = default;


  SQLSchema& operator=(SQLSchema&&) noexcept;

  SQLSchema& operator=(const SQLSchema&) = default;
  void __clear();

  ~SQLSchema();

 private:
  ::std::map<::cpp2::ColumnId, ::std::string> columnNames;
 private:
  ::std::map<::cpp2::ColumnId, ::cpp2::ColumnType> columnTypes;
 private:
  ::std::map<::cpp2::TableId, ::std::string> tableNames;
 private:
  ::std::map<::cpp2::ColumnId, ::cpp2::TableId> columnToTable;
 private:
  ::std::map<::cpp2::TableId, ::std::vector<::cpp2::ColumnId>> tableToColumns;
 private:
  ::std::map<::cpp2::ColumnId, ::cpp2::ColumnId> foreignKeys;
 private:
  ::std::vector<::cpp2::ColumnId> primaryKeys;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool columnNames;
    bool columnTypes;
    bool tableNames;
    bool columnToTable;
    bool tableToColumns;
    bool foreignKeys;
    bool primaryKeys;
  } __isset = {};

  bool operator==(const SQLSchema&) const;
  bool operator<(const SQLSchema&) const;

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> columnNames_ref() const& {
    return {this->columnNames, __isset.columnNames};
  }

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> columnNames_ref() const&& {
    return {std::move(this->columnNames), __isset.columnNames};
  }

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> columnNames_ref() & {
    return {this->columnNames, __isset.columnNames};
  }

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> columnNames_ref() && {
    return {std::move(this->columnNames), __isset.columnNames};
  }

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::cpp2::ColumnType>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> columnTypes_ref() const& {
    return {this->columnTypes, __isset.columnTypes};
  }

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::cpp2::ColumnType>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> columnTypes_ref() const&& {
    return {std::move(this->columnTypes), __isset.columnTypes};
  }

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::cpp2::ColumnType>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> columnTypes_ref() & {
    return {this->columnTypes, __isset.columnTypes};
  }

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::cpp2::ColumnType>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> columnTypes_ref() && {
    return {std::move(this->columnTypes), __isset.columnTypes};
  }

  template <typename..., typename T = ::std::map<::cpp2::TableId, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tableNames_ref() const& {
    return {this->tableNames, __isset.tableNames};
  }

  template <typename..., typename T = ::std::map<::cpp2::TableId, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tableNames_ref() const&& {
    return {std::move(this->tableNames), __isset.tableNames};
  }

  template <typename..., typename T = ::std::map<::cpp2::TableId, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tableNames_ref() & {
    return {this->tableNames, __isset.tableNames};
  }

  template <typename..., typename T = ::std::map<::cpp2::TableId, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tableNames_ref() && {
    return {std::move(this->tableNames), __isset.tableNames};
  }

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::cpp2::TableId>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> columnToTable_ref() const& {
    return {this->columnToTable, __isset.columnToTable};
  }

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::cpp2::TableId>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> columnToTable_ref() const&& {
    return {std::move(this->columnToTable), __isset.columnToTable};
  }

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::cpp2::TableId>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> columnToTable_ref() & {
    return {this->columnToTable, __isset.columnToTable};
  }

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::cpp2::TableId>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> columnToTable_ref() && {
    return {std::move(this->columnToTable), __isset.columnToTable};
  }

  template <typename..., typename T = ::std::map<::cpp2::TableId, ::std::vector<::cpp2::ColumnId>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> tableToColumns_ref() const& {
    return {this->tableToColumns, __isset.tableToColumns};
  }

  template <typename..., typename T = ::std::map<::cpp2::TableId, ::std::vector<::cpp2::ColumnId>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> tableToColumns_ref() const&& {
    return {std::move(this->tableToColumns), __isset.tableToColumns};
  }

  template <typename..., typename T = ::std::map<::cpp2::TableId, ::std::vector<::cpp2::ColumnId>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> tableToColumns_ref() & {
    return {this->tableToColumns, __isset.tableToColumns};
  }

  template <typename..., typename T = ::std::map<::cpp2::TableId, ::std::vector<::cpp2::ColumnId>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> tableToColumns_ref() && {
    return {std::move(this->tableToColumns), __isset.tableToColumns};
  }

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::cpp2::ColumnId>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> foreignKeys_ref() const& {
    return {this->foreignKeys, __isset.foreignKeys};
  }

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::cpp2::ColumnId>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> foreignKeys_ref() const&& {
    return {std::move(this->foreignKeys), __isset.foreignKeys};
  }

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::cpp2::ColumnId>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> foreignKeys_ref() & {
    return {this->foreignKeys, __isset.foreignKeys};
  }

  template <typename..., typename T = ::std::map<::cpp2::ColumnId, ::cpp2::ColumnId>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> foreignKeys_ref() && {
    return {std::move(this->foreignKeys), __isset.foreignKeys};
  }

  template <typename..., typename T = ::std::vector<::cpp2::ColumnId>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> primaryKeys_ref() const& {
    return {this->primaryKeys, __isset.primaryKeys};
  }

  template <typename..., typename T = ::std::vector<::cpp2::ColumnId>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> primaryKeys_ref() const&& {
    return {std::move(this->primaryKeys), __isset.primaryKeys};
  }

  template <typename..., typename T = ::std::vector<::cpp2::ColumnId>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> primaryKeys_ref() & {
    return {this->primaryKeys, __isset.primaryKeys};
  }

  template <typename..., typename T = ::std::vector<::cpp2::ColumnId>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> primaryKeys_ref() && {
    return {std::move(this->primaryKeys), __isset.primaryKeys};
  }
  const ::std::map<::cpp2::ColumnId, ::std::string>& get_columnNames() const&;
  ::std::map<::cpp2::ColumnId, ::std::string> get_columnNames() &&;

  template <typename T_SQLSchema_columnNames_struct_setter = ::std::map<::cpp2::ColumnId, ::std::string>>
  ::std::map<::cpp2::ColumnId, ::std::string>& set_columnNames(T_SQLSchema_columnNames_struct_setter&& columnNames_) {
    columnNames = std::forward<T_SQLSchema_columnNames_struct_setter>(columnNames_);
    __isset.columnNames = true;
    return columnNames;
  }
  const ::std::map<::cpp2::ColumnId, ::cpp2::ColumnType>& get_columnTypes() const&;
  ::std::map<::cpp2::ColumnId, ::cpp2::ColumnType> get_columnTypes() &&;

  template <typename T_SQLSchema_columnTypes_struct_setter = ::std::map<::cpp2::ColumnId, ::cpp2::ColumnType>>
  ::std::map<::cpp2::ColumnId, ::cpp2::ColumnType>& set_columnTypes(T_SQLSchema_columnTypes_struct_setter&& columnTypes_) {
    columnTypes = std::forward<T_SQLSchema_columnTypes_struct_setter>(columnTypes_);
    __isset.columnTypes = true;
    return columnTypes;
  }
  const ::std::map<::cpp2::TableId, ::std::string>& get_tableNames() const&;
  ::std::map<::cpp2::TableId, ::std::string> get_tableNames() &&;

  template <typename T_SQLSchema_tableNames_struct_setter = ::std::map<::cpp2::TableId, ::std::string>>
  ::std::map<::cpp2::TableId, ::std::string>& set_tableNames(T_SQLSchema_tableNames_struct_setter&& tableNames_) {
    tableNames = std::forward<T_SQLSchema_tableNames_struct_setter>(tableNames_);
    __isset.tableNames = true;
    return tableNames;
  }
  const ::std::map<::cpp2::ColumnId, ::cpp2::TableId>& get_columnToTable() const&;
  ::std::map<::cpp2::ColumnId, ::cpp2::TableId> get_columnToTable() &&;

  template <typename T_SQLSchema_columnToTable_struct_setter = ::std::map<::cpp2::ColumnId, ::cpp2::TableId>>
  ::std::map<::cpp2::ColumnId, ::cpp2::TableId>& set_columnToTable(T_SQLSchema_columnToTable_struct_setter&& columnToTable_) {
    columnToTable = std::forward<T_SQLSchema_columnToTable_struct_setter>(columnToTable_);
    __isset.columnToTable = true;
    return columnToTable;
  }
  const ::std::map<::cpp2::TableId, ::std::vector<::cpp2::ColumnId>>& get_tableToColumns() const&;
  ::std::map<::cpp2::TableId, ::std::vector<::cpp2::ColumnId>> get_tableToColumns() &&;

  template <typename T_SQLSchema_tableToColumns_struct_setter = ::std::map<::cpp2::TableId, ::std::vector<::cpp2::ColumnId>>>
  ::std::map<::cpp2::TableId, ::std::vector<::cpp2::ColumnId>>& set_tableToColumns(T_SQLSchema_tableToColumns_struct_setter&& tableToColumns_) {
    tableToColumns = std::forward<T_SQLSchema_tableToColumns_struct_setter>(tableToColumns_);
    __isset.tableToColumns = true;
    return tableToColumns;
  }
  const ::std::map<::cpp2::ColumnId, ::cpp2::ColumnId>& get_foreignKeys() const&;
  ::std::map<::cpp2::ColumnId, ::cpp2::ColumnId> get_foreignKeys() &&;

  template <typename T_SQLSchema_foreignKeys_struct_setter = ::std::map<::cpp2::ColumnId, ::cpp2::ColumnId>>
  ::std::map<::cpp2::ColumnId, ::cpp2::ColumnId>& set_foreignKeys(T_SQLSchema_foreignKeys_struct_setter&& foreignKeys_) {
    foreignKeys = std::forward<T_SQLSchema_foreignKeys_struct_setter>(foreignKeys_);
    __isset.foreignKeys = true;
    return foreignKeys;
  }
  const ::std::vector<::cpp2::ColumnId>& get_primaryKeys() const&;
  ::std::vector<::cpp2::ColumnId> get_primaryKeys() &&;

  template <typename T_SQLSchema_primaryKeys_struct_setter = ::std::vector<::cpp2::ColumnId>>
  ::std::vector<::cpp2::ColumnId>& set_primaryKeys(T_SQLSchema_primaryKeys_struct_setter&& primaryKeys_) {
    primaryKeys = std::forward<T_SQLSchema_primaryKeys_struct_setter>(primaryKeys_);
    __isset.primaryKeys = true;
    return primaryKeys;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<SQLSchema>;
  friend void swap(SQLSchema& a, SQLSchema& b);
};

template <class Protocol_>
uint32_t SQLSchema::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class RegisterSQLSchemaException final : public apache::thrift::TException {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;
  static constexpr ::apache::thrift::ExceptionKind __fbthrift_cpp2_gen_exception_kind =
         ::apache::thrift::ExceptionKind::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionSafety __fbthrift_cpp2_gen_exception_safety =
         ::apache::thrift::ExceptionSafety::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionBlame __fbthrift_cpp2_gen_exception_blame =
         ::apache::thrift::ExceptionBlame::UNSPECIFIED;

 public:
  using __fbthrift_cpp2_type = RegisterSQLSchemaException;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  RegisterSQLSchemaException() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RegisterSQLSchemaException(apache::thrift::FragileConstructor, ::cpp2::DBId dbId__arg, ::std::string message__arg);

  RegisterSQLSchemaException(RegisterSQLSchemaException&&) noexcept;

  RegisterSQLSchemaException(const RegisterSQLSchemaException&) = default;


  RegisterSQLSchemaException& operator=(RegisterSQLSchemaException&&) noexcept;

  RegisterSQLSchemaException& operator=(const RegisterSQLSchemaException&) = default;
  void __clear();
 private:
  ::cpp2::DBId dbId;
 private:
  ::std::string message;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool dbId;
    bool message;
  } __isset = {};

  bool operator==(const RegisterSQLSchemaException&) const;
  bool operator<(const RegisterSQLSchemaException&) const;

  template <typename..., typename T = ::cpp2::DBId>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> dbId_ref() const& {
    return {this->dbId, __isset.dbId};
  }

  template <typename..., typename T = ::cpp2::DBId>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> dbId_ref() const&& {
    return {std::move(this->dbId), __isset.dbId};
  }

  template <typename..., typename T = ::cpp2::DBId>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> dbId_ref() & {
    return {this->dbId, __isset.dbId};
  }

  template <typename..., typename T = ::cpp2::DBId>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> dbId_ref() && {
    return {std::move(this->dbId), __isset.dbId};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> message_ref() const& {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> message_ref() const&& {
    return {std::move(this->message), __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> message_ref() & {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> message_ref() && {
    return {std::move(this->message), __isset.message};
  }

  const ::cpp2::DBId& get_dbId() const& {
    return dbId;
  }

  ::cpp2::DBId get_dbId() && {
    return std::move(dbId);
  }

  template <typename T_RegisterSQLSchemaException_dbId_struct_setter = ::cpp2::DBId>
  ::cpp2::DBId& set_dbId(T_RegisterSQLSchemaException_dbId_struct_setter&& dbId_) {
    dbId = std::forward<T_RegisterSQLSchemaException_dbId_struct_setter>(dbId_);
    __isset.dbId = true;
    return dbId;
  }

  const ::std::string& get_message() const& {
    return message;
  }

  ::std::string get_message() && {
    return std::move(message);
  }

  template <typename T_RegisterSQLSchemaException_message_struct_setter = ::std::string>
  ::std::string& set_message(T_RegisterSQLSchemaException_message_struct_setter&& message_) {
    message = std::forward<T_RegisterSQLSchemaException_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

  const char* what() const noexcept override {
    return "::cpp2::RegisterSQLSchemaException";
  }

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<RegisterSQLSchemaException>;
  friend void swap(RegisterSQLSchemaException& a, RegisterSQLSchemaException& b);
};

template <class Protocol_>
uint32_t RegisterSQLSchemaException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class RegisterTokenizerException final : public apache::thrift::TException {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;
  static constexpr ::apache::thrift::ExceptionKind __fbthrift_cpp2_gen_exception_kind =
         ::apache::thrift::ExceptionKind::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionSafety __fbthrift_cpp2_gen_exception_safety =
         ::apache::thrift::ExceptionSafety::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionBlame __fbthrift_cpp2_gen_exception_blame =
         ::apache::thrift::ExceptionBlame::UNSPECIFIED;

 public:
  using __fbthrift_cpp2_type = RegisterTokenizerException;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  RegisterTokenizerException() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RegisterTokenizerException(apache::thrift::FragileConstructor, ::std::string message__arg);

  RegisterTokenizerException(RegisterTokenizerException&&) noexcept;

  RegisterTokenizerException(const RegisterTokenizerException&) = default;


  RegisterTokenizerException& operator=(RegisterTokenizerException&&) noexcept;

  RegisterTokenizerException& operator=(const RegisterTokenizerException&) = default;
  void __clear();
 private:
  ::std::string message;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool message;
  } __isset = {};

  bool operator==(const RegisterTokenizerException&) const;
  bool operator<(const RegisterTokenizerException&) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> message_ref() const& {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> message_ref() const&& {
    return {std::move(this->message), __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> message_ref() & {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> message_ref() && {
    return {std::move(this->message), __isset.message};
  }

  const ::std::string& get_message() const& {
    return message;
  }

  ::std::string get_message() && {
    return std::move(message);
  }

  template <typename T_RegisterTokenizerException_message_struct_setter = ::std::string>
  ::std::string& set_message(T_RegisterTokenizerException_message_struct_setter&& message_) {
    message = std::forward<T_RegisterTokenizerException_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

  const char* what() const noexcept override {
    return "::cpp2::RegisterTokenizerException";
  }

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<RegisterTokenizerException>;
  friend void swap(RegisterTokenizerException& a, RegisterTokenizerException& b);
};

template <class Protocol_>
uint32_t RegisterTokenizerException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class TokenizerNotRegisteredException final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = TokenizerNotRegisteredException;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  TokenizerNotRegisteredException() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  TokenizerNotRegisteredException(apache::thrift::FragileConstructor, ::std::string message__arg);

  TokenizerNotRegisteredException(TokenizerNotRegisteredException&&) noexcept;

  TokenizerNotRegisteredException(const TokenizerNotRegisteredException&) = default;


  TokenizerNotRegisteredException& operator=(TokenizerNotRegisteredException&&) noexcept;

  TokenizerNotRegisteredException& operator=(const TokenizerNotRegisteredException&) = default;
  void __clear();
 private:
  ::std::string message;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool message;
  } __isset = {};

  bool operator==(const TokenizerNotRegisteredException&) const;
  bool operator<(const TokenizerNotRegisteredException&) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> message_ref() const& {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> message_ref() const&& {
    return {std::move(this->message), __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> message_ref() & {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> message_ref() && {
    return {std::move(this->message), __isset.message};
  }

  const ::std::string& get_message() const& {
    return message;
  }

  ::std::string get_message() && {
    return std::move(message);
  }

  template <typename T_TokenizerNotRegisteredException_message_struct_setter = ::std::string>
  ::std::string& set_message(T_TokenizerNotRegisteredException_message_struct_setter&& message_) {
    message = std::forward<T_TokenizerNotRegisteredException_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<TokenizerNotRegisteredException>;
  friend void swap(TokenizerNotRegisteredException& a, TokenizerNotRegisteredException& b);
};

template <class Protocol_>
uint32_t TokenizerNotRegisteredException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class TokenizerPrefixException final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = TokenizerPrefixException;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  TokenizerPrefixException() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  TokenizerPrefixException(apache::thrift::FragileConstructor, ::std::string message__arg);

  TokenizerPrefixException(TokenizerPrefixException&&) noexcept;

  TokenizerPrefixException(const TokenizerPrefixException&) = default;


  TokenizerPrefixException& operator=(TokenizerPrefixException&&) noexcept;

  TokenizerPrefixException& operator=(const TokenizerPrefixException&) = default;
  void __clear();
 private:
  ::std::string message;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool message;
  } __isset = {};

  bool operator==(const TokenizerPrefixException&) const;
  bool operator<(const TokenizerPrefixException&) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> message_ref() const& {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> message_ref() const&& {
    return {std::move(this->message), __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> message_ref() & {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> message_ref() && {
    return {std::move(this->message), __isset.message};
  }

  const ::std::string& get_message() const& {
    return message;
  }

  ::std::string get_message() && {
    return std::move(message);
  }

  template <typename T_TokenizerPrefixException_message_struct_setter = ::std::string>
  ::std::string& set_message(T_TokenizerPrefixException_message_struct_setter&& message_) {
    message = std::forward<T_TokenizerPrefixException_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<TokenizerPrefixException>;
  friend void swap(TokenizerPrefixException& a, TokenizerPrefixException& b);
};

template <class Protocol_>
uint32_t TokenizerPrefixException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class ModeException final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ModeException;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ModeException() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ModeException(apache::thrift::FragileConstructor, ::std::string message__arg);

  ModeException(ModeException&&) noexcept;

  ModeException(const ModeException&) = default;


  ModeException& operator=(ModeException&&) noexcept;

  ModeException& operator=(const ModeException&) = default;
  void __clear();
 private:
  ::std::string message;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool message;
  } __isset = {};

  bool operator==(const ModeException&) const;
  bool operator<(const ModeException&) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> message_ref() const& {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> message_ref() const&& {
    return {std::move(this->message), __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> message_ref() & {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> message_ref() && {
    return {std::move(this->message), __isset.message};
  }

  const ::std::string& get_message() const& {
    return message;
  }

  ::std::string get_message() && {
    return std::move(message);
  }

  template <typename T_ModeException_message_struct_setter = ::std::string>
  ::std::string& set_message(T_ModeException_message_struct_setter&& message_) {
    message = std::forward<T_ModeException_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<ModeException>;
  friend void swap(ModeException& a, ModeException& b);
};

template <class Protocol_>
uint32_t ModeException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class FeedFatalException final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = FeedFatalException;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    tokenizerNotRegisteredException = 1,
    tokenizerPrefixException = 2,
    modeException = 3,
  } ;

  FeedFatalException()
      : type_(Type::__EMPTY__) {}

  FeedFatalException(FeedFatalException&& rhs) noexcept
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::tokenizerNotRegisteredException:
      {
        set_tokenizerNotRegisteredException(std::move(rhs.value_.tokenizerNotRegisteredException));
        break;
      }
      case Type::tokenizerPrefixException:
      {
        set_tokenizerPrefixException(std::move(rhs.value_.tokenizerPrefixException));
        break;
      }
      case Type::modeException:
      {
        set_modeException(std::move(rhs.value_.modeException));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  FeedFatalException(const FeedFatalException& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::tokenizerNotRegisteredException:
      {
        set_tokenizerNotRegisteredException(rhs.value_.tokenizerNotRegisteredException);
        break;
      }
      case Type::tokenizerPrefixException:
      {
        set_tokenizerPrefixException(rhs.value_.tokenizerPrefixException);
        break;
      }
      case Type::modeException:
      {
        set_modeException(rhs.value_.modeException);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  FeedFatalException& operator=(FeedFatalException&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::tokenizerNotRegisteredException:
      {
        set_tokenizerNotRegisteredException(std::move(rhs.value_.tokenizerNotRegisteredException));
        break;
      }
      case Type::tokenizerPrefixException:
      {
        set_tokenizerPrefixException(std::move(rhs.value_.tokenizerPrefixException));
        break;
      }
      case Type::modeException:
      {
        set_modeException(std::move(rhs.value_.modeException));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  FeedFatalException& operator=(const FeedFatalException& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::tokenizerNotRegisteredException:
      {
        set_tokenizerNotRegisteredException(rhs.value_.tokenizerNotRegisteredException);
        break;
      }
      case Type::tokenizerPrefixException:
      {
        set_tokenizerPrefixException(rhs.value_.tokenizerPrefixException);
        break;
      }
      case Type::modeException:
      {
        set_modeException(rhs.value_.modeException);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~FeedFatalException() {
    __clear();
  }
  union storage_type {
    ::cpp2::TokenizerNotRegisteredException tokenizerNotRegisteredException;
    ::cpp2::TokenizerPrefixException tokenizerPrefixException;
    ::cpp2::ModeException modeException;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const FeedFatalException&) const;
  bool operator<(const FeedFatalException&) const;

  ::cpp2::TokenizerNotRegisteredException& set_tokenizerNotRegisteredException(::cpp2::TokenizerNotRegisteredException const &t) {
    __clear();
    type_ = Type::tokenizerNotRegisteredException;
    ::new (std::addressof(value_.tokenizerNotRegisteredException)) ::cpp2::TokenizerNotRegisteredException(t);
    return value_.tokenizerNotRegisteredException;
  }

  ::cpp2::TokenizerNotRegisteredException& set_tokenizerNotRegisteredException(::cpp2::TokenizerNotRegisteredException&& t) {
    __clear();
    type_ = Type::tokenizerNotRegisteredException;
    ::new (std::addressof(value_.tokenizerNotRegisteredException)) ::cpp2::TokenizerNotRegisteredException(std::move(t));
    return value_.tokenizerNotRegisteredException;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::cpp2::TokenizerNotRegisteredException, T...>> ::cpp2::TokenizerNotRegisteredException& set_tokenizerNotRegisteredException(T&&... t) {
    __clear();
    type_ = Type::tokenizerNotRegisteredException;
    ::new (std::addressof(value_.tokenizerNotRegisteredException)) ::cpp2::TokenizerNotRegisteredException(std::forward<T>(t)...);
    return value_.tokenizerNotRegisteredException;
  }

  ::cpp2::TokenizerPrefixException& set_tokenizerPrefixException(::cpp2::TokenizerPrefixException const &t) {
    __clear();
    type_ = Type::tokenizerPrefixException;
    ::new (std::addressof(value_.tokenizerPrefixException)) ::cpp2::TokenizerPrefixException(t);
    return value_.tokenizerPrefixException;
  }

  ::cpp2::TokenizerPrefixException& set_tokenizerPrefixException(::cpp2::TokenizerPrefixException&& t) {
    __clear();
    type_ = Type::tokenizerPrefixException;
    ::new (std::addressof(value_.tokenizerPrefixException)) ::cpp2::TokenizerPrefixException(std::move(t));
    return value_.tokenizerPrefixException;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::cpp2::TokenizerPrefixException, T...>> ::cpp2::TokenizerPrefixException& set_tokenizerPrefixException(T&&... t) {
    __clear();
    type_ = Type::tokenizerPrefixException;
    ::new (std::addressof(value_.tokenizerPrefixException)) ::cpp2::TokenizerPrefixException(std::forward<T>(t)...);
    return value_.tokenizerPrefixException;
  }

  ::cpp2::ModeException& set_modeException(::cpp2::ModeException const &t) {
    __clear();
    type_ = Type::modeException;
    ::new (std::addressof(value_.modeException)) ::cpp2::ModeException(t);
    return value_.modeException;
  }

  ::cpp2::ModeException& set_modeException(::cpp2::ModeException&& t) {
    __clear();
    type_ = Type::modeException;
    ::new (std::addressof(value_.modeException)) ::cpp2::ModeException(std::move(t));
    return value_.modeException;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::cpp2::ModeException, T...>> ::cpp2::ModeException& set_modeException(T&&... t) {
    __clear();
    type_ = Type::modeException;
    ::new (std::addressof(value_.modeException)) ::cpp2::ModeException(std::forward<T>(t)...);
    return value_.modeException;
  }

  ::cpp2::TokenizerNotRegisteredException const& get_tokenizerNotRegisteredException() const {
    assert(type_ == Type::tokenizerNotRegisteredException);
    return value_.tokenizerNotRegisteredException;
  }

  ::cpp2::TokenizerPrefixException const& get_tokenizerPrefixException() const {
    assert(type_ == Type::tokenizerPrefixException);
    return value_.tokenizerPrefixException;
  }

  ::cpp2::ModeException const& get_modeException() const {
    assert(type_ == Type::modeException);
    return value_.modeException;
  }

  ::cpp2::TokenizerNotRegisteredException& mutable_tokenizerNotRegisteredException() {
    assert(type_ == Type::tokenizerNotRegisteredException);
    return value_.tokenizerNotRegisteredException;
  }

  ::cpp2::TokenizerPrefixException& mutable_tokenizerPrefixException() {
    assert(type_ == Type::tokenizerPrefixException);
    return value_.tokenizerPrefixException;
  }

  ::cpp2::ModeException& mutable_modeException() {
    assert(type_ == Type::modeException);
    return value_.modeException;
  }

  ::cpp2::TokenizerNotRegisteredException move_tokenizerNotRegisteredException() {
    assert(type_ == Type::tokenizerNotRegisteredException);
    return std::move(value_.tokenizerNotRegisteredException);
  }

  ::cpp2::TokenizerPrefixException move_tokenizerPrefixException() {
    assert(type_ == Type::tokenizerPrefixException);
    return std::move(value_.tokenizerPrefixException);
  }

  ::cpp2::ModeException move_modeException() {
    assert(type_ == Type::modeException);
    return std::move(value_.modeException);
  }

  template <typename..., typename T = ::cpp2::TokenizerNotRegisteredException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> tokenizerNotRegisteredException_ref() const& {
    return {value_.tokenizerNotRegisteredException, type_, tokenizerNotRegisteredException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::TokenizerNotRegisteredException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> tokenizerNotRegisteredException_ref() const&& {
    return {std::move(value_.tokenizerNotRegisteredException), type_, tokenizerNotRegisteredException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::TokenizerNotRegisteredException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> tokenizerNotRegisteredException_ref() & {
    return {value_.tokenizerNotRegisteredException, type_, tokenizerNotRegisteredException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::TokenizerNotRegisteredException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> tokenizerNotRegisteredException_ref() && {
    return {std::move(value_.tokenizerNotRegisteredException), type_, tokenizerNotRegisteredException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::cpp2::TokenizerPrefixException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> tokenizerPrefixException_ref() const& {
    return {value_.tokenizerPrefixException, type_, tokenizerPrefixException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::TokenizerPrefixException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> tokenizerPrefixException_ref() const&& {
    return {std::move(value_.tokenizerPrefixException), type_, tokenizerPrefixException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::TokenizerPrefixException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> tokenizerPrefixException_ref() & {
    return {value_.tokenizerPrefixException, type_, tokenizerPrefixException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::TokenizerPrefixException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> tokenizerPrefixException_ref() && {
    return {std::move(value_.tokenizerPrefixException), type_, tokenizerPrefixException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::cpp2::ModeException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> modeException_ref() const& {
    return {value_.modeException, type_, modeException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::ModeException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> modeException_ref() const&& {
    return {std::move(value_.modeException), type_, modeException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::ModeException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> modeException_ref() & {
    return {value_.modeException, type_, modeException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::ModeException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> modeException_ref() && {
    return {std::move(value_.modeException), type_, modeException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<FeedFatalException>;
  friend void swap(FeedFatalException& a, FeedFatalException& b);
};

template <class Protocol_>
uint32_t FeedFatalException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class FeedException final : public apache::thrift::TException {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;
  static constexpr ::apache::thrift::ExceptionKind __fbthrift_cpp2_gen_exception_kind =
         ::apache::thrift::ExceptionKind::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionSafety __fbthrift_cpp2_gen_exception_safety =
         ::apache::thrift::ExceptionSafety::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionBlame __fbthrift_cpp2_gen_exception_blame =
         ::apache::thrift::ExceptionBlame::UNSPECIFIED;

 public:
  using __fbthrift_cpp2_type = FeedException;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  FeedException() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  FeedException(apache::thrift::FragileConstructor, ::cpp2::FeedFatalException feedFatalException__arg);

  FeedException(FeedException&&) noexcept;

  FeedException(const FeedException&) = default;


  FeedException& operator=(FeedException&&) noexcept;

  FeedException& operator=(const FeedException&) = default;
  void __clear();
 private:
  ::cpp2::FeedFatalException feedFatalException;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool feedFatalException;
  } __isset = {};

  bool operator==(const FeedException&) const;
  bool operator<(const FeedException&) const;

  template <typename..., typename T = ::cpp2::FeedFatalException>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> feedFatalException_ref() const& {
    return {this->feedFatalException, __isset.feedFatalException};
  }

  template <typename..., typename T = ::cpp2::FeedFatalException>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> feedFatalException_ref() const&& {
    return {std::move(this->feedFatalException), __isset.feedFatalException};
  }

  template <typename..., typename T = ::cpp2::FeedFatalException>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> feedFatalException_ref() & {
    return {this->feedFatalException, __isset.feedFatalException};
  }

  template <typename..., typename T = ::cpp2::FeedFatalException>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> feedFatalException_ref() && {
    return {std::move(this->feedFatalException), __isset.feedFatalException};
  }
  const ::cpp2::FeedFatalException& get_feedFatalException() const&;
  ::cpp2::FeedFatalException get_feedFatalException() &&;

  template <typename T_FeedException_feedFatalException_struct_setter = ::cpp2::FeedFatalException>
  ::cpp2::FeedFatalException& set_feedFatalException(T_FeedException_feedFatalException_struct_setter&& feedFatalException_) {
    feedFatalException = std::forward<T_FeedException_feedFatalException_struct_setter>(feedFatalException_);
    __isset.feedFatalException = true;
    return feedFatalException;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

  const char* what() const noexcept override {
    return "::cpp2::FeedException";
  }

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<FeedException>;
  friend void swap(FeedException& a, FeedException& b);
};

template <class Protocol_>
uint32_t FeedException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class FeedParseFailure final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = FeedParseFailure;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  FeedParseFailure() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  FeedParseFailure(apache::thrift::FragileConstructor, ::std::string input__arg, ::std::vector<::std::string> contexts__arg, ::std::string description__arg);

  FeedParseFailure(FeedParseFailure&&) noexcept;

  FeedParseFailure(const FeedParseFailure&) = default;


  FeedParseFailure& operator=(FeedParseFailure&&) noexcept;

  FeedParseFailure& operator=(const FeedParseFailure&) = default;
  void __clear();
 private:
  ::std::string input;
 private:
  ::std::vector<::std::string> contexts;
 private:
  ::std::string description;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool input;
    bool contexts;
    bool description;
  } __isset = {};

  bool operator==(const FeedParseFailure&) const;
  bool operator<(const FeedParseFailure&) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> input_ref() const& {
    return {this->input, __isset.input};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> input_ref() const&& {
    return {std::move(this->input), __isset.input};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> input_ref() & {
    return {this->input, __isset.input};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> input_ref() && {
    return {std::move(this->input), __isset.input};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> contexts_ref() const& {
    return {this->contexts, __isset.contexts};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> contexts_ref() const&& {
    return {std::move(this->contexts), __isset.contexts};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> contexts_ref() & {
    return {this->contexts, __isset.contexts};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> contexts_ref() && {
    return {std::move(this->contexts), __isset.contexts};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> description_ref() const& {
    return {this->description, __isset.description};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> description_ref() const&& {
    return {std::move(this->description), __isset.description};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> description_ref() & {
    return {this->description, __isset.description};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> description_ref() && {
    return {std::move(this->description), __isset.description};
  }

  const ::std::string& get_input() const& {
    return input;
  }

  ::std::string get_input() && {
    return std::move(input);
  }

  template <typename T_FeedParseFailure_input_struct_setter = ::std::string>
  ::std::string& set_input(T_FeedParseFailure_input_struct_setter&& input_) {
    input = std::forward<T_FeedParseFailure_input_struct_setter>(input_);
    __isset.input = true;
    return input;
  }
  const ::std::vector<::std::string>& get_contexts() const&;
  ::std::vector<::std::string> get_contexts() &&;

  template <typename T_FeedParseFailure_contexts_struct_setter = ::std::vector<::std::string>>
  ::std::vector<::std::string>& set_contexts(T_FeedParseFailure_contexts_struct_setter&& contexts_) {
    contexts = std::forward<T_FeedParseFailure_contexts_struct_setter>(contexts_);
    __isset.contexts = true;
    return contexts;
  }

  const ::std::string& get_description() const& {
    return description;
  }

  ::std::string get_description() && {
    return std::move(description);
  }

  template <typename T_FeedParseFailure_description_struct_setter = ::std::string>
  ::std::string& set_description(T_FeedParseFailure_description_struct_setter&& description_) {
    description = std::forward<T_FeedParseFailure_description_struct_setter>(description_);
    __isset.description = true;
    return description;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<FeedParseFailure>;
  friend void swap(FeedParseFailure& a, FeedParseFailure& b);
};

template <class Protocol_>
uint32_t FeedParseFailure::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class FeedTimeoutFailure final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = FeedTimeoutFailure;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  FeedTimeoutFailure() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  FeedTimeoutFailure(apache::thrift::FragileConstructor, ::std::string message__arg);

  FeedTimeoutFailure(FeedTimeoutFailure&&) noexcept;

  FeedTimeoutFailure(const FeedTimeoutFailure&) = default;


  FeedTimeoutFailure& operator=(FeedTimeoutFailure&&) noexcept;

  FeedTimeoutFailure& operator=(const FeedTimeoutFailure&) = default;
  void __clear();
 private:
  ::std::string message;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool message;
  } __isset = {};

  bool operator==(const FeedTimeoutFailure&) const;
  bool operator<(const FeedTimeoutFailure&) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> message_ref() const& {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> message_ref() const&& {
    return {std::move(this->message), __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> message_ref() & {
    return {this->message, __isset.message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> message_ref() && {
    return {std::move(this->message), __isset.message};
  }

  const ::std::string& get_message() const& {
    return message;
  }

  ::std::string get_message() && {
    return std::move(message);
  }

  template <typename T_FeedTimeoutFailure_message_struct_setter = ::std::string>
  ::std::string& set_message(T_FeedTimeoutFailure_message_struct_setter&& message_) {
    message = std::forward<T_FeedTimeoutFailure_message_struct_setter>(message_);
    __isset.message = true;
    return message;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<FeedTimeoutFailure>;
  friend void swap(FeedTimeoutFailure& a, FeedTimeoutFailure& b);
};

template <class Protocol_>
uint32_t FeedTimeoutFailure::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class FeedPartialSuccess final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = FeedPartialSuccess;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  FeedPartialSuccess() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  FeedPartialSuccess(apache::thrift::FragileConstructor);

  FeedPartialSuccess(FeedPartialSuccess&&) = default;

  FeedPartialSuccess(const FeedPartialSuccess&) = default;


  FeedPartialSuccess& operator=(FeedPartialSuccess&&) = default;

  FeedPartialSuccess& operator=(const FeedPartialSuccess&) = default;
  void __clear();

  bool operator==(const FeedPartialSuccess&) const;
  bool operator<(const FeedPartialSuccess&) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<FeedPartialSuccess>;
  friend void swap(FeedPartialSuccess& a, FeedPartialSuccess& b);
};

template <class Protocol_>
uint32_t FeedPartialSuccess::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class FeedCompleteSuccess final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = FeedCompleteSuccess;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  FeedCompleteSuccess() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  FeedCompleteSuccess(apache::thrift::FragileConstructor, ::std::string leftover__arg);

  FeedCompleteSuccess(FeedCompleteSuccess&&) noexcept;

  FeedCompleteSuccess(const FeedCompleteSuccess&) = default;


  FeedCompleteSuccess& operator=(FeedCompleteSuccess&&) noexcept;

  FeedCompleteSuccess& operator=(const FeedCompleteSuccess&) = default;
  void __clear();
 private:
  ::std::string leftover;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool leftover;
  } __isset = {};

  bool operator==(const FeedCompleteSuccess&) const;
  bool operator<(const FeedCompleteSuccess&) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> leftover_ref() const& {
    return {this->leftover, __isset.leftover};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> leftover_ref() const&& {
    return {std::move(this->leftover), __isset.leftover};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> leftover_ref() & {
    return {this->leftover, __isset.leftover};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> leftover_ref() && {
    return {std::move(this->leftover), __isset.leftover};
  }

  const ::std::string& get_leftover() const& {
    return leftover;
  }

  ::std::string get_leftover() && {
    return std::move(leftover);
  }

  template <typename T_FeedCompleteSuccess_leftover_struct_setter = ::std::string>
  ::std::string& set_leftover(T_FeedCompleteSuccess_leftover_struct_setter&& leftover_) {
    leftover = std::forward<T_FeedCompleteSuccess_leftover_struct_setter>(leftover_);
    __isset.leftover = true;
    return leftover;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<FeedCompleteSuccess>;
  friend void swap(FeedCompleteSuccess& a, FeedCompleteSuccess& b);
};

template <class Protocol_>
uint32_t FeedCompleteSuccess::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class FeedResult final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = FeedResult;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    feedParseFailure = 1,
    feedTimeoutFailure = 2,
    feedPartialSuccess = 3,
    feedCompleteSuccess = 4,
  } ;

  FeedResult()
      : type_(Type::__EMPTY__) {}

  FeedResult(FeedResult&& rhs) noexcept
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::feedParseFailure:
      {
        set_feedParseFailure(std::move(rhs.value_.feedParseFailure));
        break;
      }
      case Type::feedTimeoutFailure:
      {
        set_feedTimeoutFailure(std::move(rhs.value_.feedTimeoutFailure));
        break;
      }
      case Type::feedPartialSuccess:
      {
        set_feedPartialSuccess(std::move(rhs.value_.feedPartialSuccess));
        break;
      }
      case Type::feedCompleteSuccess:
      {
        set_feedCompleteSuccess(std::move(rhs.value_.feedCompleteSuccess));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  FeedResult(const FeedResult& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::feedParseFailure:
      {
        set_feedParseFailure(rhs.value_.feedParseFailure);
        break;
      }
      case Type::feedTimeoutFailure:
      {
        set_feedTimeoutFailure(rhs.value_.feedTimeoutFailure);
        break;
      }
      case Type::feedPartialSuccess:
      {
        set_feedPartialSuccess(rhs.value_.feedPartialSuccess);
        break;
      }
      case Type::feedCompleteSuccess:
      {
        set_feedCompleteSuccess(rhs.value_.feedCompleteSuccess);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  FeedResult& operator=(FeedResult&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::feedParseFailure:
      {
        set_feedParseFailure(std::move(rhs.value_.feedParseFailure));
        break;
      }
      case Type::feedTimeoutFailure:
      {
        set_feedTimeoutFailure(std::move(rhs.value_.feedTimeoutFailure));
        break;
      }
      case Type::feedPartialSuccess:
      {
        set_feedPartialSuccess(std::move(rhs.value_.feedPartialSuccess));
        break;
      }
      case Type::feedCompleteSuccess:
      {
        set_feedCompleteSuccess(std::move(rhs.value_.feedCompleteSuccess));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  FeedResult& operator=(const FeedResult& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::feedParseFailure:
      {
        set_feedParseFailure(rhs.value_.feedParseFailure);
        break;
      }
      case Type::feedTimeoutFailure:
      {
        set_feedTimeoutFailure(rhs.value_.feedTimeoutFailure);
        break;
      }
      case Type::feedPartialSuccess:
      {
        set_feedPartialSuccess(rhs.value_.feedPartialSuccess);
        break;
      }
      case Type::feedCompleteSuccess:
      {
        set_feedCompleteSuccess(rhs.value_.feedCompleteSuccess);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~FeedResult() {
    __clear();
  }
  union storage_type {
    ::cpp2::FeedParseFailure feedParseFailure;
    ::cpp2::FeedTimeoutFailure feedTimeoutFailure;
    ::cpp2::FeedPartialSuccess feedPartialSuccess;
    ::cpp2::FeedCompleteSuccess feedCompleteSuccess;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const FeedResult&) const;
  bool operator<(const FeedResult&) const;

  ::cpp2::FeedParseFailure& set_feedParseFailure(::cpp2::FeedParseFailure const &t) {
    __clear();
    type_ = Type::feedParseFailure;
    ::new (std::addressof(value_.feedParseFailure)) ::cpp2::FeedParseFailure(t);
    return value_.feedParseFailure;
  }

  ::cpp2::FeedParseFailure& set_feedParseFailure(::cpp2::FeedParseFailure&& t) {
    __clear();
    type_ = Type::feedParseFailure;
    ::new (std::addressof(value_.feedParseFailure)) ::cpp2::FeedParseFailure(std::move(t));
    return value_.feedParseFailure;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::cpp2::FeedParseFailure, T...>> ::cpp2::FeedParseFailure& set_feedParseFailure(T&&... t) {
    __clear();
    type_ = Type::feedParseFailure;
    ::new (std::addressof(value_.feedParseFailure)) ::cpp2::FeedParseFailure(std::forward<T>(t)...);
    return value_.feedParseFailure;
  }

  ::cpp2::FeedTimeoutFailure& set_feedTimeoutFailure(::cpp2::FeedTimeoutFailure const &t) {
    __clear();
    type_ = Type::feedTimeoutFailure;
    ::new (std::addressof(value_.feedTimeoutFailure)) ::cpp2::FeedTimeoutFailure(t);
    return value_.feedTimeoutFailure;
  }

  ::cpp2::FeedTimeoutFailure& set_feedTimeoutFailure(::cpp2::FeedTimeoutFailure&& t) {
    __clear();
    type_ = Type::feedTimeoutFailure;
    ::new (std::addressof(value_.feedTimeoutFailure)) ::cpp2::FeedTimeoutFailure(std::move(t));
    return value_.feedTimeoutFailure;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::cpp2::FeedTimeoutFailure, T...>> ::cpp2::FeedTimeoutFailure& set_feedTimeoutFailure(T&&... t) {
    __clear();
    type_ = Type::feedTimeoutFailure;
    ::new (std::addressof(value_.feedTimeoutFailure)) ::cpp2::FeedTimeoutFailure(std::forward<T>(t)...);
    return value_.feedTimeoutFailure;
  }

  ::cpp2::FeedPartialSuccess& set_feedPartialSuccess(::cpp2::FeedPartialSuccess const &t) {
    __clear();
    type_ = Type::feedPartialSuccess;
    ::new (std::addressof(value_.feedPartialSuccess)) ::cpp2::FeedPartialSuccess(t);
    return value_.feedPartialSuccess;
  }

  ::cpp2::FeedPartialSuccess& set_feedPartialSuccess(::cpp2::FeedPartialSuccess&& t) {
    __clear();
    type_ = Type::feedPartialSuccess;
    ::new (std::addressof(value_.feedPartialSuccess)) ::cpp2::FeedPartialSuccess(std::move(t));
    return value_.feedPartialSuccess;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::cpp2::FeedPartialSuccess, T...>> ::cpp2::FeedPartialSuccess& set_feedPartialSuccess(T&&... t) {
    __clear();
    type_ = Type::feedPartialSuccess;
    ::new (std::addressof(value_.feedPartialSuccess)) ::cpp2::FeedPartialSuccess(std::forward<T>(t)...);
    return value_.feedPartialSuccess;
  }

  ::cpp2::FeedCompleteSuccess& set_feedCompleteSuccess(::cpp2::FeedCompleteSuccess const &t) {
    __clear();
    type_ = Type::feedCompleteSuccess;
    ::new (std::addressof(value_.feedCompleteSuccess)) ::cpp2::FeedCompleteSuccess(t);
    return value_.feedCompleteSuccess;
  }

  ::cpp2::FeedCompleteSuccess& set_feedCompleteSuccess(::cpp2::FeedCompleteSuccess&& t) {
    __clear();
    type_ = Type::feedCompleteSuccess;
    ::new (std::addressof(value_.feedCompleteSuccess)) ::cpp2::FeedCompleteSuccess(std::move(t));
    return value_.feedCompleteSuccess;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::cpp2::FeedCompleteSuccess, T...>> ::cpp2::FeedCompleteSuccess& set_feedCompleteSuccess(T&&... t) {
    __clear();
    type_ = Type::feedCompleteSuccess;
    ::new (std::addressof(value_.feedCompleteSuccess)) ::cpp2::FeedCompleteSuccess(std::forward<T>(t)...);
    return value_.feedCompleteSuccess;
  }

  ::cpp2::FeedParseFailure const& get_feedParseFailure() const {
    assert(type_ == Type::feedParseFailure);
    return value_.feedParseFailure;
  }

  ::cpp2::FeedTimeoutFailure const& get_feedTimeoutFailure() const {
    assert(type_ == Type::feedTimeoutFailure);
    return value_.feedTimeoutFailure;
  }

  ::cpp2::FeedPartialSuccess const& get_feedPartialSuccess() const {
    assert(type_ == Type::feedPartialSuccess);
    return value_.feedPartialSuccess;
  }

  ::cpp2::FeedCompleteSuccess const& get_feedCompleteSuccess() const {
    assert(type_ == Type::feedCompleteSuccess);
    return value_.feedCompleteSuccess;
  }

  ::cpp2::FeedParseFailure& mutable_feedParseFailure() {
    assert(type_ == Type::feedParseFailure);
    return value_.feedParseFailure;
  }

  ::cpp2::FeedTimeoutFailure& mutable_feedTimeoutFailure() {
    assert(type_ == Type::feedTimeoutFailure);
    return value_.feedTimeoutFailure;
  }

  ::cpp2::FeedPartialSuccess& mutable_feedPartialSuccess() {
    assert(type_ == Type::feedPartialSuccess);
    return value_.feedPartialSuccess;
  }

  ::cpp2::FeedCompleteSuccess& mutable_feedCompleteSuccess() {
    assert(type_ == Type::feedCompleteSuccess);
    return value_.feedCompleteSuccess;
  }

  ::cpp2::FeedParseFailure move_feedParseFailure() {
    assert(type_ == Type::feedParseFailure);
    return std::move(value_.feedParseFailure);
  }

  ::cpp2::FeedTimeoutFailure move_feedTimeoutFailure() {
    assert(type_ == Type::feedTimeoutFailure);
    return std::move(value_.feedTimeoutFailure);
  }

  ::cpp2::FeedPartialSuccess move_feedPartialSuccess() {
    assert(type_ == Type::feedPartialSuccess);
    return std::move(value_.feedPartialSuccess);
  }

  ::cpp2::FeedCompleteSuccess move_feedCompleteSuccess() {
    assert(type_ == Type::feedCompleteSuccess);
    return std::move(value_.feedCompleteSuccess);
  }

  template <typename..., typename T = ::cpp2::FeedParseFailure>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> feedParseFailure_ref() const& {
    return {value_.feedParseFailure, type_, feedParseFailure, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::FeedParseFailure>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> feedParseFailure_ref() const&& {
    return {std::move(value_.feedParseFailure), type_, feedParseFailure, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::FeedParseFailure>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> feedParseFailure_ref() & {
    return {value_.feedParseFailure, type_, feedParseFailure, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::FeedParseFailure>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> feedParseFailure_ref() && {
    return {std::move(value_.feedParseFailure), type_, feedParseFailure, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::cpp2::FeedTimeoutFailure>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> feedTimeoutFailure_ref() const& {
    return {value_.feedTimeoutFailure, type_, feedTimeoutFailure, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::FeedTimeoutFailure>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> feedTimeoutFailure_ref() const&& {
    return {std::move(value_.feedTimeoutFailure), type_, feedTimeoutFailure, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::FeedTimeoutFailure>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> feedTimeoutFailure_ref() & {
    return {value_.feedTimeoutFailure, type_, feedTimeoutFailure, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::FeedTimeoutFailure>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> feedTimeoutFailure_ref() && {
    return {std::move(value_.feedTimeoutFailure), type_, feedTimeoutFailure, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::cpp2::FeedPartialSuccess>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> feedPartialSuccess_ref() const& {
    return {value_.feedPartialSuccess, type_, feedPartialSuccess, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::FeedPartialSuccess>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> feedPartialSuccess_ref() const&& {
    return {std::move(value_.feedPartialSuccess), type_, feedPartialSuccess, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::FeedPartialSuccess>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> feedPartialSuccess_ref() & {
    return {value_.feedPartialSuccess, type_, feedPartialSuccess, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::FeedPartialSuccess>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> feedPartialSuccess_ref() && {
    return {std::move(value_.feedPartialSuccess), type_, feedPartialSuccess, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::cpp2::FeedCompleteSuccess>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> feedCompleteSuccess_ref() const& {
    return {value_.feedCompleteSuccess, type_, feedCompleteSuccess, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::FeedCompleteSuccess>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> feedCompleteSuccess_ref() const&& {
    return {std::move(value_.feedCompleteSuccess), type_, feedCompleteSuccess, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::FeedCompleteSuccess>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> feedCompleteSuccess_ref() & {
    return {value_.feedCompleteSuccess, type_, feedCompleteSuccess, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::FeedCompleteSuccess>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> feedCompleteSuccess_ref() && {
    return {std::move(value_.feedCompleteSuccess), type_, feedCompleteSuccess, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<FeedResult>;
  friend void swap(FeedResult& a, FeedResult& b);
};

template <class Protocol_>
uint32_t FeedResult::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
#ifndef SWIG
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;
#endif

class BatchFeedResult final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = BatchFeedResult;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  BatchFeedResult() :
      batchId(0),
      topToken(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  BatchFeedResult(apache::thrift::FragileConstructor, ::cpp2::BatchId batchId__arg, ::cpp2::Token topToken__arg, ::cpp2::FeedResult feedResult__arg);

  BatchFeedResult(BatchFeedResult&&) noexcept;

  BatchFeedResult(const BatchFeedResult&) = default;


  BatchFeedResult& operator=(BatchFeedResult&&) noexcept;

  BatchFeedResult& operator=(const BatchFeedResult&) = default;
  void __clear();
 private:
  ::cpp2::BatchId batchId;
 private:
  ::cpp2::Token topToken;
 private:
  ::cpp2::FeedResult feedResult;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool batchId;
    bool topToken;
    bool feedResult;
  } __isset = {};

  bool operator==(const BatchFeedResult&) const;
  bool operator<(const BatchFeedResult&) const;

  template <typename..., typename T = ::cpp2::BatchId>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> batchId_ref() const& {
    return {this->batchId, __isset.batchId};
  }

  template <typename..., typename T = ::cpp2::BatchId>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> batchId_ref() const&& {
    return {std::move(this->batchId), __isset.batchId};
  }

  template <typename..., typename T = ::cpp2::BatchId>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> batchId_ref() & {
    return {this->batchId, __isset.batchId};
  }

  template <typename..., typename T = ::cpp2::BatchId>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> batchId_ref() && {
    return {std::move(this->batchId), __isset.batchId};
  }

  template <typename..., typename T = ::cpp2::Token>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> topToken_ref() const& {
    return {this->topToken, __isset.topToken};
  }

  template <typename..., typename T = ::cpp2::Token>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> topToken_ref() const&& {
    return {std::move(this->topToken), __isset.topToken};
  }

  template <typename..., typename T = ::cpp2::Token>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> topToken_ref() & {
    return {this->topToken, __isset.topToken};
  }

  template <typename..., typename T = ::cpp2::Token>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> topToken_ref() && {
    return {std::move(this->topToken), __isset.topToken};
  }

  template <typename..., typename T = ::cpp2::FeedResult>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> feedResult_ref() const& {
    return {this->feedResult, __isset.feedResult};
  }

  template <typename..., typename T = ::cpp2::FeedResult>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> feedResult_ref() const&& {
    return {std::move(this->feedResult), __isset.feedResult};
  }

  template <typename..., typename T = ::cpp2::FeedResult>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> feedResult_ref() & {
    return {this->feedResult, __isset.feedResult};
  }

  template <typename..., typename T = ::cpp2::FeedResult>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> feedResult_ref() && {
    return {std::move(this->feedResult), __isset.feedResult};
  }

  ::cpp2::BatchId get_batchId() const {
    return batchId;
  }

  ::cpp2::BatchId& set_batchId(::cpp2::BatchId batchId_) {
    batchId = batchId_;
    __isset.batchId = true;
    return batchId;
  }

  ::cpp2::Token get_topToken() const {
    return topToken;
  }

  ::cpp2::Token& set_topToken(::cpp2::Token topToken_) {
    topToken = topToken_;
    __isset.topToken = true;
    return topToken;
  }
  const ::cpp2::FeedResult& get_feedResult() const&;
  ::cpp2::FeedResult get_feedResult() &&;

  template <typename T_BatchFeedResult_feedResult_struct_setter = ::cpp2::FeedResult>
  ::cpp2::FeedResult& set_feedResult(T_BatchFeedResult_feedResult_struct_setter&& feedResult_) {
    feedResult = std::forward<T_BatchFeedResult_feedResult_struct_setter>(feedResult_);
    __isset.feedResult = true;
    return feedResult;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<BatchFeedResult>;
  friend void swap(BatchFeedResult& a, BatchFeedResult& b);
};

template <class Protocol_>
uint32_t BatchFeedResult::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
THRIFT_IGNORE_ISSET_USE_WARNING_END

namespace apache { namespace thrift {

template <> struct TEnumDataStorage<::cpp2::FeedFatalException::Type>;

template <> struct TEnumTraits<::cpp2::FeedFatalException::Type> {
  using type = ::cpp2::FeedFatalException::Type;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};

template <> struct TEnumDataStorage<::cpp2::FeedResult::Type>;

template <> struct TEnumTraits<::cpp2::FeedResult::Type> {
  using type = ::cpp2::FeedResult::Type;

  static constexpr std::size_t const size = 4;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};
}} // apache::thrift
